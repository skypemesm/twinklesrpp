.TH "OutgoingDataQueue" 3 "21 Sep 2010" "ccRTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
OutgoingDataQueue \- 
.PP
A generic outgoing RTP data queue supporting multiple destinations.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <oqueue.h>\fP
.PP
Inherits \fBOutgoingDataQueueBase\fP, and \fBDestinationListHandler\fP.
.PP
Inherited by \fBRTPDataQueue\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBOutgoingRTPPktLink\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBaddDestination\fP (const InetHostAddress &ia, tpport_t dataPort=\fBDefaultRTPDataPort\fP, tpport_t controlPort=0)"
.br
.ti -1c
.RI "bool \fBaddDestination\fP (const InetMcastAddress &ia, tpport_t dataPort=\fBDefaultRTPDataPort\fP, tpport_t controlPort=0)"
.br
.ti -1c
.RI "bool \fBforgetDestination\fP (const InetHostAddress &ia, tpport_t dataPort=\fBDefaultRTPDataPort\fP, tpport_t controlPort=0)"
.br
.ti -1c
.RI "bool \fBforgetDestination\fP (const InetMcastAddress &ia, tpport_t dataPort=\fBDefaultRTPDataPort\fP, tpport_t controlPort=0)"
.br
.ti -1c
.RI "void \fBaddContributor\fP (uint32 csrc)"
.br
.RI "\fIAdd csrc as the CSRC identifier of a new contributor. \fP"
.ti -1c
.RI "bool \fBremoveContributor\fP (uint32 csrc)"
.br
.RI "\fIRemove CSRC from the list of contributors. \fP"
.ti -1c
.RI "bool \fBisSending\fP () const "
.br
.RI "\fIDetermine if outgoing packets are waiting to send. \fP"
.ti -1c
.RI "void \fBputData\fP (uint32 stamp, const unsigned char *data=NULL, size_t len=0)"
.br
.RI "\fIThis is used to create a data packet in the send queue. \fP"
.ti -1c
.RI "void \fBsendImmediate\fP (uint32 stamp, const unsigned char *data=NULL, size_t len=0)"
.br
.RI "\fIThis is used to create a data packet and send it immediately. \fP"
.ti -1c
.RI "void \fBsetPadding\fP (uint8 \fBpaddinglen\fP)"
.br
.RI "\fISet padding. \fP"
.ti -1c
.RI "void \fBsetMark\fP (bool mark)"
.br
.RI "\fISet marker bit for the packet in which the next data provided will be send. \fP"
.ti -1c
.RI "bool \fBgetMark\fP () const "
.br
.RI "\fIGet wheter the mark bit will be set in the next packet. \fP"
.ti -1c
.RI "size_t \fBsetPartial\fP (uint32 timestamp, unsigned char *data, size_t offset, size_t max)"
.br
.RI "\fISet partial data for an already queued packet. \fP"
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetDefaultSchedulingTimeout\fP () const "
.br
.ti -1c
.RI "void \fBsetSchedulingTimeout\fP (\fBmicrotimeout_t\fP to)"
.br
.RI "\fISet the default scheduling timeout to use when no data packets are waiting to be sent. \fP"
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetDefaultExpireTimeout\fP () const "
.br
.ti -1c
.RI "void \fBsetExpireTimeout\fP (\fBmicrotimeout_t\fP to)"
.br
.RI "\fISet the 'expired' timer for expiring packets pending in the send queue which have gone unsent and are already 'too late' to be sent now. \fP"
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetExpireTimeout\fP () const "
.br
.ti -1c
.RI "uint32 \fBgetSendPacketCount\fP () const "
.br
.RI "\fIGet the total number of packets sent so far. \fP"
.ti -1c
.RI "uint32 \fBgetSendOctetCount\fP () const "
.br
.RI "\fIGet the total number of octets (payload only) sent so far. \fP"
.ti -1c
.RI "uint16 \fBgetSequenceNumber\fP () const "
.br
.RI "\fIGet the sequence number of the next outgoing packet. \fP"
.ti -1c
.RI "void \fBsetOutQueueCryptoContext\fP (\fBCryptoContext\fP *cc)"
.br
.RI "\fISet ouput queue \fBCryptoContext\fP. \fP"
.ti -1c
.RI "void \fBremoveOutQueueCryptoContext\fP (\fBCryptoContext\fP *cc)"
.br
.RI "\fIRemove output queue \fBCryptoContext\fP. \fP"
.ti -1c
.RI "\fBCryptoContext\fP * \fBgetOutQueueCryptoContext\fP (uint32 ssrc)"
.br
.RI "\fIGet an output queue \fBCryptoContext\fP identified by SSRC. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBOutgoingDataQueue\fP ()"
.br
.ti -1c
.RI "virtual \fB~OutgoingDataQueue\fP ()"
.br
.ti -1c
.RI "void \fBdispatchImmediate\fP (\fBOutgoingRTPPkt\fP *packet)"
.br
.RI "\fIThis is used to write the RTP data packet to one or more destinations. \fP"
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetSchedulingTimeout\fP ()"
.br
.RI "\fIThis computes the timeout period for scheduling transmission of the next packet at the 'head' of the send buffer. \fP"
.ti -1c
.RI "size_t \fBdispatchDataPacket\fP ()"
.br
.RI "\fIThis function is used by the service thread to process the next outgoing packet pending in the sending queue. \fP"
.ti -1c
.RI "void \fBsetNextSeqNum\fP (uint32 seqNum)"
.br
.RI "\fIFor thoses cases in which the application requires a method to set the sequence number for the outgoing stream (such as for implementing the RTSP PLAY command). \fP"
.ti -1c
.RI "uint32 \fBgetCurrentSeqNum\fP (void)"
.br
.ti -1c
.RI "void \fBsetInitialTimestamp\fP (uint32 ts)"
.br
.ti -1c
.RI "uint32 \fBgetInitialTimestamp\fP ()"
.br
.ti -1c
.RI "void \fBpurgeOutgoingQueue\fP ()"
.br
.ti -1c
.RI "virtual void \fBsetControlPeer\fP (const InetAddress &host, tpport_t port)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "Mutex \fBcryptoMutex\fP"
.br
.ti -1c
.RI "std::list< \fBCryptoContext\fP * > \fBcryptoContexts\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A generic outgoing RTP data queue supporting multiple destinations. 

\fBAuthor:\fP
.RS 4
Federico Montesino Pouzols <fedemp@altern.org> 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "OutgoingDataQueue::OutgoingDataQueue ()\fC [protected]\fP"
.SS "virtual OutgoingDataQueue::~OutgoingDataQueue ()\fC [inline, protected, virtual]\fP"
.SH "Member Function Documentation"
.PP 
.SS "void OutgoingDataQueue::addContributor (uint32 csrc)"
.PP
Add csrc as the CSRC identifier of a new contributor. This method adds the CSRC identifier to a list of contributors that will be inserted in every packet enqueued from now on. 
.SS "bool OutgoingDataQueue::addDestination (const InetMcastAddress & ia, tpport_t dataPort = \fC\fBDefaultRTPDataPort\fP\fP, tpport_t controlPort = \fC0\fP)"
.SS "bool OutgoingDataQueue::addDestination (const InetHostAddress & ia, tpport_t dataPort = \fC\fBDefaultRTPDataPort\fP\fP, tpport_t controlPort = \fC0\fP)"
.SS "size_t OutgoingDataQueue::dispatchDataPacket ()\fC [protected]\fP"
.PP
This function is used by the service thread to process the next outgoing packet pending in the sending queue. \fBReturns:\fP
.RS 4
number of bytes sent. 0 if silent, <0 if error. 
.RE
.PP

.SS "void OutgoingDataQueue::dispatchImmediate (\fBOutgoingRTPPkt\fP * packet)\fC [protected]\fP"
.PP
This is used to write the RTP data packet to one or more destinations. It is used by both sendImmediate and by dispatchDataPacket.
.PP
\fBParameters:\fP
.RS 4
\fIRTP\fP packet to send. 
.RE
.PP

.SS "bool OutgoingDataQueue::forgetDestination (const InetMcastAddress & ia, tpport_t dataPort = \fC\fBDefaultRTPDataPort\fP\fP, tpport_t controlPort = \fC0\fP)"
.SS "bool OutgoingDataQueue::forgetDestination (const InetHostAddress & ia, tpport_t dataPort = \fC\fBDefaultRTPDataPort\fP\fP, tpport_t controlPort = \fC0\fP)"
.SS "uint32 OutgoingDataQueue::getCurrentSeqNum (void)\fC [inline, protected]\fP"
.SS "\fBmicrotimeout_t\fP OutgoingDataQueue::getDefaultExpireTimeout () const\fC [inline]\fP"
.SS "\fBmicrotimeout_t\fP OutgoingDataQueue::getDefaultSchedulingTimeout () const\fC [inline]\fP"
.SS "\fBmicrotimeout_t\fP OutgoingDataQueue::getExpireTimeout () const\fC [inline]\fP"
.SS "uint32 OutgoingDataQueue::getInitialTimestamp ()\fC [inline, protected]\fP"
.SS "bool OutgoingDataQueue::getMark () const\fC [inline]\fP"
.PP
Get wheter the mark bit will be set in the next packet. 
.SS "\fBCryptoContext\fP* OutgoingDataQueue::getOutQueueCryptoContext (uint32 ssrc)"
.PP
Get an output queue \fBCryptoContext\fP identified by SSRC. \fBParameters:\fP
.RS 4
\fIssrc\fP Request \fBCryptoContext\fP for this incoming SSRC 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to \fBCryptoContext\fP of the SSRC of NULL if no context available for this SSRC. 
.RE
.PP

.SS "\fBmicrotimeout_t\fP OutgoingDataQueue::getSchedulingTimeout ()\fC [protected]\fP"
.PP
This computes the timeout period for scheduling transmission of the next packet at the 'head' of the send buffer. If no packets are waiting, a default timeout is used. This actually forms the 'isPending()' timeout of the rtp receiver in the service thread.
.PP
\fBReturns:\fP
.RS 4
timeout until next packet is scheduled to send. 
.RE
.PP

.SS "uint32 OutgoingDataQueue::getSendOctetCount () const\fC [inline]\fP"
.PP
Get the total number of octets (payload only) sent so far. \fBReturns:\fP
.RS 4
total number of payload octets sent in RTP packets. 
.RE
.PP

.SS "uint32 OutgoingDataQueue::getSendPacketCount () const\fC [inline]\fP"
.PP
Get the total number of packets sent so far. \fBReturns:\fP
.RS 4
total number of packets sent 
.RE
.PP

.SS "uint16 OutgoingDataQueue::getSequenceNumber () const\fC [inline]\fP"
.PP
Get the sequence number of the next outgoing packet. \fBReturns:\fP
.RS 4
the 16 bit sequence number. 
.RE
.PP

.SS "bool OutgoingDataQueue::isSending () const"
.PP
Determine if outgoing packets are waiting to send. \fBReturns:\fP
.RS 4
true if there are packets waiting to be send. 
.RE
.PP

.SS "void OutgoingDataQueue::purgeOutgoingQueue ()\fC [protected]\fP"
.SS "void OutgoingDataQueue::putData (uint32 stamp, const unsigned char * data = \fCNULL\fP, size_t len = \fC0\fP)"
.PP
This is used to create a data packet in the send queue. Sometimes a 'NULL' or empty packet will be used instead, and these are known as 'silent' packets. 'Silent' packets are used simply to 'push' the scheduler along more accurately by giving the appearence that a next packet is waiting to be sent and to provide a valid timestamp for that packet.
.PP
\fBParameters:\fP
.RS 4
\fIstamp\fP Timestamp for expected send time of packet. 
.br
\fIdata\fP Value or NULL if special 'silent' packet. 
.br
\fIlen\fP May be 0 to indicate a default by payload type. 
.RE
.PP

.SS "bool OutgoingDataQueue::removeContributor (uint32 csrc)"
.PP
Remove CSRC from the list of contributors. 
.SS "void OutgoingDataQueue::removeOutQueueCryptoContext (\fBCryptoContext\fP * cc)"
.PP
Remove output queue \fBCryptoContext\fP. The endQueue method (provided by RTPQueue) also deletes all registered CryptoContexts.
.PP
\fBParameters:\fP
.RS 4
\fIcc\fP Pointer to initialized \fBCryptoContext\fP to remove. 
.RE
.PP

.SS "void OutgoingDataQueue::sendImmediate (uint32 stamp, const unsigned char * data = \fCNULL\fP, size_t len = \fC0\fP)"
.PP
This is used to create a data packet and send it immediately. Sometimes a 'NULL' or empty packet will be used instead, and these are known as 'silent' packets. 'Silent' packets are used simply to 'push' the scheduler along more accurately by giving the appearence that a next packet is waiting to be sent and to provide a valid timestamp for that packet.
.PP
\fBParameters:\fP
.RS 4
\fIstamp\fP Timestamp immediate send time of packet. 
.br
\fIdata\fP Value or NULL if special 'silent' packet. 
.br
\fIlen\fP May be 0 to indicate a default by payload type. 
.RE
.PP

.SS "virtual void OutgoingDataQueue::setControlPeer (const InetAddress & host, tpport_t port)\fC [inline, protected, virtual]\fP"
.PP
Reimplemented in \fBRTPDuplex\fP.
.SS "void OutgoingDataQueue::setExpireTimeout (\fBmicrotimeout_t\fP to)\fC [inline]\fP"
.PP
Set the 'expired' timer for expiring packets pending in the send queue which have gone unsent and are already 'too late' to be sent now. \fBParameters:\fP
.RS 4
\fIto\fP timeout to expire unsent packets in milliseconds. 
.RE
.PP

.SS "void OutgoingDataQueue::setInitialTimestamp (uint32 ts)\fC [inline, protected]\fP"
.SS "void OutgoingDataQueue::setMark (bool mark)\fC [inline]\fP"
.PP
Set marker bit for the packet in which the next data provided will be send. When transmitting audio, should be set for the first packet of a talk spurt. When transmitting video, should be set for the last packet for a video frame.
.PP
\fBParameters:\fP
.RS 4
\fImark\fP Marker bit value for next packet. 
.RE
.PP

.SS "void OutgoingDataQueue::setNextSeqNum (uint32 seqNum)\fC [inline, protected]\fP"
.PP
For thoses cases in which the application requires a method to set the sequence number for the outgoing stream (such as for implementing the RTSP PLAY command). \fBParameters:\fP
.RS 4
\fIseqNum\fP next sequence number to be used for outgoing packets. 
.RE
.PP

.SS "void OutgoingDataQueue::setOutQueueCryptoContext (\fBCryptoContext\fP * cc)"
.PP
Set ouput queue \fBCryptoContext\fP. The endQueue method (provided by RTPQueue) deletes all registered CryptoContexts.
.PP
\fBParameters:\fP
.RS 4
\fIcc\fP Pointer to initialized \fBCryptoContext\fP. 
.RE
.PP

.SS "void OutgoingDataQueue::setPadding (uint8 paddinglen)\fC [inline]\fP"
.PP
Set padding. All outgoing packets will be transparently padded to a multiple of paddinglen.
.PP
\fBParameters:\fP
.RS 4
\fIpaddinglen\fP pad packets to a length multiple of paddinglen. 
.RE
.PP

.SS "size_t OutgoingDataQueue::setPartial (uint32 timestamp, unsigned char * data, size_t offset, size_t max)"
.PP
Set partial data for an already queued packet. This is often used for multichannel data.
.PP
\fBParameters:\fP
.RS 4
\fItimestamp\fP Timestamp of packet. 
.br
\fIdata\fP Buffer to copy from. 
.br
\fIoffset\fP Offset to copy from. 
.br
\fImax\fP Maximum data size. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of packet data bytes set. 
.RE
.PP

.SS "void OutgoingDataQueue::setSchedulingTimeout (\fBmicrotimeout_t\fP to)\fC [inline]\fP"
.PP
Set the default scheduling timeout to use when no data packets are waiting to be sent. \fBParameters:\fP
.RS 4
\fIto\fP timeout in milliseconds. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "bool \fBOutgoingDataQueue::complete\fP"
.SS "std::list<\fBCryptoContext\fP *> \fBOutgoingDataQueue::cryptoContexts\fP\fC [protected]\fP"
.SS "Mutex \fBOutgoingDataQueue::cryptoMutex\fP\fC [mutable, protected]\fP"
.SS "bool \fBOutgoingDataQueue::marked\fP"
.SS "uint32 \fBOutgoingDataQueue::octetCount\fP"
.SS "timeval \fBOutgoingDataQueue::overflowTime\fP"
.SS "uint32 \fBOutgoingDataQueue::packetCount\fP"
.SS "uint8 \fBOutgoingDataQueue::paddinglen\fP"
.SS "uint16 \fBOutgoingDataQueue::sendCC\fP"
.SS "uint16 \fBOutgoingDataQueue::sendSeq\fP"
.SS "uint32 \fBOutgoingDataQueue::sendSources\fP[16]"

.SH "Author"
.PP 
Generated automatically by Doxygen for ccRTP from the source code.
