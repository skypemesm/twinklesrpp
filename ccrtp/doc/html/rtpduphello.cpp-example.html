<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ccRTP: rtpduphello.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>rtpduphello.cpp</h1><p>A basic example of how to use <a class="el" href="class_r_t_p_duplex.html" title="A peer associated RTP socket pair for physically connected peer hosts.">RTPDuplex</a></p>
<div class="fragment"><pre class="fragment"><span class="comment">// rtpduphello. </span>
<span class="comment">// A very simple program for testing and illustrating basic features of ccRTP.</span>
<span class="comment">// Copyright (C) 2001,2002  Federico Montesino &lt;fedemp@altern.org&gt;</span>
<span class="comment">//  </span>
<span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<span class="comment">// it under the terms of the GNU General Public License as published by</span>
<span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment">// (at your option) any later version.</span>
<span class="comment">//  </span>
<span class="comment">// This program is distributed in the hope that it will be useful,</span>
<span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment">// GNU General Public License for more details.</span>
<span class="comment">//  </span>
<span class="comment">// You should have received a copy of the GNU General Public License</span>
<span class="comment">// along with this program; if not, write to the Free Software</span>
<span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>


<span class="comment">// This is an introductory example file that illustrates basic usage</span>
<span class="comment">// of ccRTP. You will also see a bit on how to use CommonC++ threads.</span>

<span class="comment">// It is a typical hello world program. It consists of tow duplex</span>
<span class="comment">// connections that talk each other through RTP packets. They do not</span>
<span class="comment">// say more than a typical salutation message. They both send and</span>
<span class="comment">// receive messages, and print the messages they receive.</span>


<span class="preprocessor">#include &lt;cstdio&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="comment">// In order to use ccRTP, the RTP stack of CommonC++, you only need to</span>
<span class="comment">// include ...</span>
<span class="preprocessor">#include &lt;<a class="code" href="ext_8h.html" title="ccRTP Stack extensions.">ccrtp/ext.h</a>&gt;</span>

<span class="preprocessor">#ifdef  CCXX_NAMESPACES</span>
<span class="preprocessor"></span><span class="keyword">using namespace </span>ost;
<span class="keyword">using namespace </span>std;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">class </span>ccRTP_dupHello: <span class="keyword">public</span> Thread
{
<span class="keyword">private</span>:
        <span class="comment">// There will be two duplex connections. They both will send</span>
        <span class="comment">// and receive packets.</span>
        <a name="_a0"></a><a class="code" href="class_r_t_p_duplex.html" title="A peer associated RTP socket pair for physically connected peer hosts.">RTPDuplex</a> *duplexA, *duplexB;
        
<span class="keyword">public</span>:
        <span class="comment">// Destructor.</span>
        ~ccRTP_dupHello(){
                terminate();
                <span class="keyword">delete</span> duplexA;
                <span class="keyword">delete</span> duplexB;  
        }
        
        <span class="comment">// Constructor.</span>
        ccRTP_dupHello() : duplexA(NULL), duplexB(NULL)
        { }

        <span class="comment">// This method does almost everything.</span>
        <span class="keywordtype">void</span> run(<span class="keywordtype">void</span>){    
                <span class="comment">// redefined from Thread.</span>
                
                <span class="comment">// Before using ccRTP you should learn something about other</span>
                <span class="comment">// CommonC++ classes. We need InetHostAddress...</span>

                <span class="comment">// Construct loopback address</span>
                InetHostAddress local_ip;
                local_ip = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;
                
                <span class="comment">// Is that correct?</span>
                <span class="keywordflow">if</span>( ! local_ip ){  
                <span class="comment">// this is equivalent to `! local_ip.isInetAddress()&#39;</span>
                        cerr &lt;&lt; <span class="stringliteral">&quot;: IP address is not correct!&quot;</span> &lt;&lt; endl;
                        exit();
                }
                
                cout &lt;&lt; local_ip.getHostname() &lt;&lt; 
                        <span class="stringliteral">&quot; is going to talk to perself through &quot;</span> &lt;&lt;
                        local_ip &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;
                                
                <span class="comment">// ____Here comes the real RTP stuff____</span>
                
                <span class="comment">// Construct two RTPSocket. 22222 will be the base</span>
                <span class="comment">// port of A.  33334 will be the base port of B.</span>
                <span class="keyword">const</span> <span class="keywordtype">int</span> A_BASE = 22222;
                <span class="keyword">const</span> <span class="keywordtype">int</span> B_BASE = 33334;

                duplexA = <span class="keyword">new</span> <a class="code" href="class_r_t_p_duplex.html" title="A peer associated RTP socket pair for physically connected peer hosts.">RTPDuplex</a>(local_ip,A_BASE,B_BASE);
                
                duplexB = <span class="keyword">new</span> <a class="code" href="class_r_t_p_duplex.html" title="A peer associated RTP socket pair for physically connected peer hosts.">RTPDuplex</a>(local_ip,B_BASE,A_BASE);

                <span class="comment">// Set up A&#39;s connection</span>
                duplexA-&gt;setSchedulingTimeout(90000);
                duplexA-&gt;setExpireTimeout(2500000);
                <span class="keywordflow">if</span>( duplexA-&gt;connect(local_ip,B_BASE) &lt; 0 )
                        cerr &lt;&lt; <span class="stringliteral">&quot;Duplex A could not connect.&quot;</span>;
                
                <span class="comment">// Set up B&#39;s connection</span>
                duplexB-&gt;setSchedulingTimeout(160000);  
                duplexB-&gt;setExpireTimeout(3500000);
                <span class="keywordflow">if</span>( duplexB-&gt;connect(local_ip,A_BASE) &lt; 0 )
                        cerr &lt;&lt; <span class="stringliteral">&quot;Duplex B could not connect.&quot;</span>;
                
                <span class="comment">// Let&#39;s check the queues  (you should read the documentation</span>
                <span class="comment">// so that you know what the queues are for).</span>
                
                <span class="keywordflow">if</span>( duplexA-&gt;RTPDataQueue::isActive() )
                        cout &lt;&lt; <span class="stringliteral">&quot;The queue A is active.&quot;</span> &lt;&lt; endl;
                <span class="keywordflow">else</span>
                        cerr &lt;&lt; <span class="stringliteral">&quot;The queue  A is not active.&quot;</span> &lt;&lt; endl;
                
                <span class="keywordflow">if</span>( duplexB-&gt;RTPDataQueue::isActive() )
                        cout &lt;&lt; <span class="stringliteral">&quot;The queue B is active.&quot;</span> &lt;&lt; endl;
                <span class="keywordflow">else</span>
                        cerr &lt;&lt; <span class="stringliteral">&quot;The queue B is not active.&quot;</span> &lt;&lt; endl;
                

                cout &lt;&lt; <span class="stringliteral">&quot;Transmitting...&quot;</span> &lt;&lt; endl;
                
                <span class="comment">// This message will be sent on RTP packets, from A to</span>
                <span class="comment">// B and from B to A.</span>
                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> helloA[] = <span class="stringliteral">&quot;Hello, brave gnu world from A!&quot;</span>;
                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> helloB[] = <span class="stringliteral">&quot;Hello, brave gnu world from B!&quot;</span>;

                <span class="comment">// This is not important</span>
                time_t sending_time;
                time_t receiving_time;
                <span class="keywordtype">char</span> tmstring[30];

                <a name="_a1"></a><a class="code" href="class_static_payload_format.html" title="Static payload format objects.">StaticPayloadFormat</a> pf = <a name="a2"></a><a class="code" href="group__payload.html#gga7644623ce29b8ca519d7e3f276b6ddc6a3f5b07dca910f599be16c871ebbb29d1" title="MPEG 2 Transport stream (RFCs 1890, 2250).">sptMP2T</a>;
                duplexA-&gt;setPayloadFormat(pf);
                duplexB-&gt;setPayloadFormat(pf);

                <span class="comment">// This is the main loop, where packets are sent and receipt.</span>
                <span class="comment">// A and B both will send and receive packets.</span>
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0 ; true ; i++ ){

                        <span class="comment">// A and B do almost exactly the same things,</span>
                        <span class="comment">// I have kept this here -out of a send/receive</span>
                        <span class="comment">// method- in the interest of clarity.</span>

                        <span class="comment">// A: Send an RTP packet                        </span>
                        sending_time = time(NULL);
                        duplexA-&gt;putData(2*(i)*90000,helloA,
                                          strlen((<span class="keywordtype">char</span> *)helloA));
                        <span class="comment">// Tell it</span>
                        strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,localtime(&amp;sending_time));
                        cout &lt;&lt; <span class="stringliteral">&quot;A: sending message at &quot;</span> &lt;&lt; tmstring &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> 
                             &lt;&lt; endl;

                        <span class="comment">// A: Receive an RTP packet</span>
                        receiving_time = time(NULL);
                        <span class="keyword">const</span> <a name="_a3"></a><a class="code" href="class_app_data_unit.html" title="Interface (envelope) to data received over RTP packets.">AppDataUnit</a>* aduA = 
                                duplexA-&gt;getData(duplexA-&gt;getFirstTimestamp());
                        <span class="keywordflow">if</span> ( aduA ) {
                                <span class="comment">// Tell it</span>
                                strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,localtime(&amp;receiving_time));
                                cout &lt;&lt; <span class="stringliteral">&quot;A:[receiving at &quot;</span> &lt;&lt; tmstring &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; 
                                        aduA-&gt;<a name="a4"></a><a class="code" href="class_app_data_unit.html#abe15787e1cc84dd03b0769a5546d7a38" title="Get data as it is received in RTP packets (i.e.">getData</a>() &lt;&lt; endl;
                        }
                        <span class="comment">// Wait for 0.1 seconds</span>
                        Thread::sleep(100);

                        <span class="comment">// B: Send an RTP packet                        </span>
                        sending_time = time(NULL);
                        duplexB-&gt;putData(2*(i)*90000,helloB,
                                         strlen((<span class="keywordtype">char</span> *)helloB));
                        <span class="comment">// Tell it</span>
                        strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,localtime(&amp;sending_time));
                        cout &lt;&lt; <span class="stringliteral">&quot;B: sending message at &quot;</span> &lt;&lt; tmstring &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> 
                             &lt;&lt; endl;

                        <span class="comment">// B: Receive an RTP packet</span>
                        receiving_time = time(NULL);
                        <span class="keyword">const</span> <a class="code" href="class_app_data_unit.html" title="Interface (envelope) to data received over RTP packets.">AppDataUnit</a>* aduB = 
                                duplexB-&gt;getData(duplexB-&gt;getFirstTimestamp());
                        <span class="keywordflow">if</span> ( aduB ) {
                                <span class="comment">// Tell it</span>
                                strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,localtime(&amp;receiving_time));
                                cout &lt;&lt; <span class="stringliteral">&quot;B:[receiving at &quot;</span> &lt;&lt; tmstring &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; 
                                        aduB-&gt;<a class="code" href="class_app_data_unit.html#abe15787e1cc84dd03b0769a5546d7a38" title="Get data as it is received in RTP packets (i.e.">getData</a>() &lt;&lt; endl;
                        }

                        Thread::sleep(1900);
                }

        }
};

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
        <span class="comment">// Construct the main thread. It will not run yet.</span>
        ccRTP_dupHello *hello = <span class="keyword">new</span> ccRTP_dupHello;
        
        cout &lt;&lt; <span class="stringliteral">&quot;This is rtpduphello, a very simple test program for ccRTP.&quot;</span> 
             &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Strike [Enter] when you are fed up.&quot;</span> &lt;&lt; endl;
        
        <span class="comment">// Start execution of hello.</span>
        hello-&gt;start();
        
        cin.get();

        cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;That&#39;s all&quot;</span> &lt;&lt; endl;

        <span class="keyword">delete</span> hello;

        exit(0);
}

</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Sep 21 04:20:08 2010 for ccRTP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
