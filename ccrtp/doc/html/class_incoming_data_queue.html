<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ccRTP: IncomingDataQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>IncomingDataQueue Class Reference<br/>
<small>
[<a class="el" href="group__iqueue.html">Generic RTP input queues.</a>]</small>
</h1><!-- doxytag: class="IncomingDataQueue" --><!-- doxytag: inherits="IncomingDataQueueBase,MembershipBookkeeping" -->
<p>Queue for incoming RTP data packets in an RTP session.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iqueue_8h_source.html">iqueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IncomingDataQueue:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_incoming_data_queue.png" usemap="#IncomingDataQueue_map" alt=""/>
  <map id="IncomingDataQueue_map" name="IncomingDataQueue_map">
<area href="class_incoming_data_queue_base.html" alt="IncomingDataQueueBase" shape="rect" coords="0,56,154,80"/>
<area href="class_membership_bookkeeping.html" alt="MembershipBookkeeping" shape="rect" coords="492,56,646,80"/>
<area href="class_r_t_p_queue_base.html" alt="RTPQueueBase" shape="rect" coords="0,0,154,24"/>
<area href="class_sync_source_handler.html" alt="SyncSourceHandler" shape="rect" coords="164,0,318,24"/>
<area href="class_participant_handler.html" alt="ParticipantHandler" shape="rect" coords="328,0,482,24"/>
<area href="class_application_handler.html" alt="ApplicationHandler" shape="rect" coords="492,0,646,24"/>
<area href="class_conflict_handler.html" alt="ConflictHandler" shape="rect" coords="656,0,810,24"/>
<area href="class_members.html" alt="Members" shape="rect" coords="820,0,974,24"/>
<area href="class_r_t_p_data_queue.html" alt="RTPDataQueue" shape="rect" coords="246,168,400,192"/>
<area href="class_queue_r_t_c_p_manager.html" alt="QueueRTCPManager" shape="rect" coords="164,224,318,248"/>
<area href="class_r_t_p_duplex.html" alt="RTPDuplex" shape="rect" coords="328,224,482,248"/>
<area href="class_a_v_p_queue.html" alt="AVPQueue" shape="rect" coords="164,280,318,304"/>
</map>
 </div>
</div>

<p><a href="class_incoming_data_queue-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue_1_1_sync_sources_iterator.html">SyncSourcesIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterator through the list of synchronizations sources in this session  <a href="class_incoming_data_queue_1_1_sync_sources_iterator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_incoming_data_queue_1_1_sync_sources_iterator.html">SyncSourcesIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#ae5a5e445035fbb67badde97b917bb396">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_incoming_data_queue_1_1_sync_sources_iterator.html">SyncSourcesIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a717fd60c11da7f1b4d9544070e30d226">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_app_data_unit.html">AppDataUnit</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a830c8a49a36dcd3e30c4e98f15e8af14">getData</a> (uint32 stamp, const <a class="el" href="class_sync_source.html">SyncSource</a> *src=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retreive data from a specific timestamped packet if such a packet is currently available in the receive buffer.  <a href="#a830c8a49a36dcd3e30c4e98f15e8af14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#aeb51f4a1018fed3e2e25937a03cedde2">isWaiting</a> (const <a class="el" href="class_sync_source.html">SyncSource</a> *src=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if packets are waiting in the reception queue.  <a href="#aeb51f4a1018fed3e2e25937a03cedde2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#ac46dbd1d341af3fa0c20e8115f78cf28">getFirstTimestamp</a> (const <a class="el" href="class_sync_source.html">SyncSource</a> *src=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get timestamp of first packet waiting in the queue.  <a href="#ac46dbd1d341af3fa0c20e8115f78cf28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a67c0dd360533faeaf3bd317fdf5fb8e3">setMinValidPacketSequence</a> (uint8 packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When receiving packets from a new source, it may be convenient to reject a first few packets before we are really sure the source is valid.  <a href="#a67c0dd360533faeaf3bd317fdf5fb8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#aa63891f27d03ebf075ade0ab9629c012">getDefaultMinValidPacketSequence</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#acee16af6cefc82db3b31d023b67f6d8d">getMinValidPacketSequence</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the minimun number of consecutive packets that must be received from a source before accepting its data packets.  <a href="#acee16af6cefc82db3b31d023b67f6d8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a602ef8706aa0b5fb2fcee2695b7be98d">setMaxPacketMisorder</a> (uint16 packets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a2498e30b14e70ce2db42d98a25ef1880">getDefaultMaxPacketMisorder</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a14f4d8c287a3f100258ed8a0e45d9759">getMaxPacketMisorder</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a731b655bf21873cfe3d24cff51c9c399">setMaxPacketDropout</a> (uint16 packets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It also prevents packets sent after a restart of the source being immediately accepted.  <a href="#a731b655bf21873cfe3d24cff51c9c399"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a5c33852bc72267276849060ee0a25332">getDefaultMaxPacketDropout</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a7e7c15767869fdf758f67b64afaaca70">getMaxPacketDropout</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a77098469cdf43464c881e1e4087f9465">setInQueueCryptoContext</a> (<a class="el" href="class_crypto_context.html">CryptoContext</a> *cc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a>.  <a href="#a77098469cdf43464c881e1e4087f9465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a9c0b5cbed6adb254d3c72081b47daa5e">removeInQueueCryptoContext</a> (<a class="el" href="class_crypto_context.html">CryptoContext</a> *cc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a>.  <a href="#a9c0b5cbed6adb254d3c72081b47daa5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_crypto_context.html">CryptoContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a1ba52ac671aa6938c916b64d0b861503">getInQueueCryptoContext</a> (uint32 ssrc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a> identified by SSRC.  <a href="#a1ba52ac671aa6938c916b64d0b861503"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a71992a5b9daf02bc65fcc2ca351b9127">getDefaultMembersSize</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#af7b901455320c83f0b5ed6c4ab26a98a">IncomingDataQueue</a> (uint32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a975f3457950992a17392a599e3b06813">~IncomingDataQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a996ac43426aff46ecdf8e7da1fdd7390">checkSSRCInIncomingRTPPkt</a> (<a class="el" href="struct_membership_bookkeeping_1_1_sync_source_link.html">SyncSourceLink</a> &amp;sourceLink, bool is_new, InetAddress &amp;na, tpport_t tp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply collision and loop detection and correction algorithm when receiving RTP data packets.  <a href="#a996ac43426aff46ecdf8e7da1fdd7390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a6c595148215e5bf4098ff0e13d1ccfb7">setSourceExpirationPeriod</a> (uint8 intervals)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of RTCP intervals that the stack will wait to change the state of a source from stateActive to stateInactive, or to delete the source after being in stateInactive.  <a href="#a6c595148215e5bf4098ff0e13d1ccfb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#afd2073e2efcf4843a54a710ff543643f">takeInDataPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used by the service thread to process the next incoming packet and place it in the receive list.  <a href="#afd2073e2efcf4843a54a710ff543643f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a7a8b5c6c0e3c934cece8e909a499efd6">renewLocalSSRC</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingDataQueue::IncomingRTPPktLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a93207595215c402ce706d01448a9dacf">getWaiting</a> (uint32 timestamp, const <a class="el" href="class_sync_source.html">SyncSource</a> *src=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is used to fetch a packet in the receive queue and to expire packets older than the current timestamp.  <a href="#a93207595215c402ce706d01448a9dacf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a628cb3c8b6f4f0b31952aa9138105c69">recordReception</a> (<a class="el" href="struct_membership_bookkeeping_1_1_sync_source_link.html">SyncSourceLink</a> &amp;srcLink, const <a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;pkt, const timeval recvtime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log reception of a new RTP packet from this source.  <a href="#a628cb3c8b6f4f0b31952aa9138105c69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a33827293af289391ecb1b227aac14158">recordExtraction</a> (const <a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log extraction of a packet from this source from the scheduled reception queue.  <a href="#a33827293af289391ecb1b227aac14158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#ab247b353020527a917db9aaba5bb5dde">purgeIncomingQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a7b75da6823836f59673bafaa6b3859c4">onNewSyncSource</a> (const <a class="el" href="class_sync_source.html">SyncSource</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual called when a new synchronization source has joined the session.  <a href="#a7b75da6823836f59673bafaa6b3859c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#ab85042be854f1a366627f0ab3f5b800d">onRTPPacketRecv</a> (<a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A virtual function to support parsing of arriving packets to determine if they should be kept in the queue and to dispatch events.  <a href="#ab85042be854f1a366627f0ab3f5b800d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a5d1fda86e7bf629ccb2fbc85a0edb27f">onExpireRecv</a> (<a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hook to filter packets in the receive queue that are being expired.  <a href="#a5d1fda86e7bf629ccb2fbc85a0edb27f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a9c3bfb8ae52bda2bff43f62784cf24d5">onSRTPPacketError</a> (<a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;pkt, int32 errorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hook that gets called if the decoding of an incoming SRTP was erroneous.  <a href="#a9c3bfb8ae52bda2bff43f62784cf24d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a5f747ec737400666e0d410e66ab6246d">end2EndDelayed</a> (<a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a09b23b4a1cac969a663a7f64cd45f7d3">insertRecvPacket</a> (<a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> *packetLink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a just received packet in the queue (both general and source specific queues).  <a href="#a09b23b4a1cac969a663a7f64cd45f7d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#aea541eb5abb237557d63d131160ce5f0">recvData</a> (unsigned char *buffer, size_t length, InetHostAddress &amp;host, tpport_t &amp;port)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs the physical I/O for reading a packet from the source.  <a href="#aea541eb5abb237557d63d131160ce5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#ac884b9005077f3320e6b9b5fc3694589">getNextDataPacketSize</a> () const =0</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ThreadLock&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#adccf839d9a491cdf98fb2f4f3e13d5d7">recvLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a93562ccedcba87b2abf91f890868cab6">recvFirst</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a5d5fc37470fbf038b374664dcfc96435">recvLast</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a7f5902996f89705f0d85df36a9778787">minValidPacketSequence</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a425682bbc96cc0401aafffea0fd59bbd">maxPacketMisorder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#aadcc24fdfc96c87f0dfa7c3b6a9c64e8">maxPacketDropout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a8d59b8ffbf0b1951e294650ab2a8ef8f">sourceExpirationPeriod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a963d974350fd1482bcd2e53ed9821afe">cryptoMutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="class_crypto_context.html">CryptoContext</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#aff53fe9c29f8c092b9bfbad60934d420">cryptoContexts</a></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#afd2b5c6ec4ef8eab87645a3cad177bd1">defaultMinValidPacketSequence</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a8620d1560ddb2450505b06f3ab488698">defaultMaxPacketMisorder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a03c2083686a6352960ea364ff0247c0b">defaultMaxPacketDropout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_incoming_data_queue.html#a01202d358cef0bf703b2991236b15c9e">defaultMembersSize</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Queue for incoming RTP data packets in an RTP session. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Federico Montesino Pouzols &lt;<a href="mailto:fedemp@altern.org">fedemp@altern.org</a>&gt; </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7b901455320c83f0b5ed6c4ab26a98a"></a><!-- doxytag: member="IncomingDataQueue::IncomingDataQueue" ref="af7b901455320c83f0b5ed6c4ab26a98a" args="(uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IncomingDataQueue::IncomingDataQueue </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>initial size of the membership table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a975f3457950992a17392a599e3b06813"></a><!-- doxytag: member="IncomingDataQueue::~IncomingDataQueue" ref="a975f3457950992a17392a599e3b06813" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual IncomingDataQueue::~IncomingDataQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae5a5e445035fbb67badde97b917bb396"></a><!-- doxytag: member="IncomingDataQueue::begin" ref="ae5a5e445035fbb67badde97b917bb396" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_incoming_data_queue_1_1_sync_sources_iterator.html">SyncSourcesIterator</a> IncomingDataQueue::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a996ac43426aff46ecdf8e7da1fdd7390"></a><!-- doxytag: member="IncomingDataQueue::checkSSRCInIncomingRTPPkt" ref="a996ac43426aff46ecdf8e7da1fdd7390" args="(SyncSourceLink &amp;sourceLink, bool is_new, InetAddress &amp;na, tpport_t tp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IncomingDataQueue::checkSSRCInIncomingRTPPkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_membership_bookkeeping_1_1_sync_source_link.html">SyncSourceLink</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InetAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tpport_t&nbsp;</td>
          <td class="paramname"> <em>tp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply collision and loop detection and correction algorithm when receiving RTP data packets. </p>
<p>Follows section 8.2 in draft-ietf-avt-rtp-new.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceLink</em>&nbsp;</td><td>link to the source object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_new</em>&nbsp;</td><td>whether the source has been just recorded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>na</em>&nbsp;</td><td>data packet network address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>data packet source transport port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether the packet must not be discarded. </dd></dl>

</div>
</div>
<a class="anchor" id="a717fd60c11da7f1b4d9544070e30d226"></a><!-- doxytag: member="IncomingDataQueue::end" ref="a717fd60c11da7f1b4d9544070e30d226" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_incoming_data_queue_1_1_sync_sources_iterator.html">SyncSourcesIterator</a> IncomingDataQueue::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f747ec737400666e0d410e66ab6246d"></a><!-- doxytag: member="IncomingDataQueue::end2EndDelayed" ref="a5f747ec737400666e0d410e66ab6246d" args="(IncomingRTPPktLink &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IncomingDataQueue::end2EndDelayed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a830c8a49a36dcd3e30c4e98f15e8af14"></a><!-- doxytag: member="IncomingDataQueue::getData" ref="a830c8a49a36dcd3e30c4e98f15e8af14" args="(uint32 stamp, const SyncSource *src=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_app_data_unit.html">AppDataUnit</a>* IncomingDataQueue::getData </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>stamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sync_source.html">SyncSource</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retreive data from a specific timestamped packet if such a packet is currently available in the receive buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stamp</em>&nbsp;</td><td>Data unit timestamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Optional synchronization source selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data retrieved from the reception buffer. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>null</em>&nbsp;</td><td>pointer if no packet with such timestamp is available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c33852bc72267276849060ee0a25332"></a><!-- doxytag: member="IncomingDataQueue::getDefaultMaxPacketDropout" ref="a5c33852bc72267276849060ee0a25332" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 IncomingDataQueue::getDefaultMaxPacketDropout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2498e30b14e70ce2db42d98a25ef1880"></a><!-- doxytag: member="IncomingDataQueue::getDefaultMaxPacketMisorder" ref="a2498e30b14e70ce2db42d98a25ef1880" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 IncomingDataQueue::getDefaultMaxPacketMisorder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a71992a5b9daf02bc65fcc2ca351b9127"></a><!-- doxytag: member="IncomingDataQueue::getDefaultMembersSize" ref="a71992a5b9daf02bc65fcc2ca351b9127" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t IncomingDataQueue::getDefaultMembersSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa63891f27d03ebf075ade0ab9629c012"></a><!-- doxytag: member="IncomingDataQueue::getDefaultMinValidPacketSequence" ref="aa63891f27d03ebf075ade0ab9629c012" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 IncomingDataQueue::getDefaultMinValidPacketSequence </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac46dbd1d341af3fa0c20e8115f78cf28"></a><!-- doxytag: member="IncomingDataQueue::getFirstTimestamp" ref="ac46dbd1d341af3fa0c20e8115f78cf28" args="(const SyncSource *src=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 IncomingDataQueue::getFirstTimestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sync_source.html">SyncSource</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get timestamp of first packet waiting in the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>optional source selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>timestamp of first arrival packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ba52ac671aa6938c916b64d0b861503"></a><!-- doxytag: member="IncomingDataQueue::getInQueueCryptoContext" ref="a1ba52ac671aa6938c916b64d0b861503" args="(uint32 ssrc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_crypto_context.html">CryptoContext</a>* IncomingDataQueue::getInQueueCryptoContext </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>ssrc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a> identified by SSRC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ssrc</em>&nbsp;</td><td>Request <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a> for this incoming SSRC </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a> of the SSRC of NULL if no context available for this SSRC. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7c15767869fdf758f67b64afaaca70"></a><!-- doxytag: member="IncomingDataQueue::getMaxPacketDropout" ref="a7e7c15767869fdf758f67b64afaaca70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 IncomingDataQueue::getMaxPacketDropout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14f4d8c287a3f100258ed8a0e45d9759"></a><!-- doxytag: member="IncomingDataQueue::getMaxPacketMisorder" ref="a14f4d8c287a3f100258ed8a0e45d9759" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 IncomingDataQueue::getMaxPacketMisorder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acee16af6cefc82db3b31d023b67f6d8d"></a><!-- doxytag: member="IncomingDataQueue::getMinValidPacketSequence" ref="acee16af6cefc82db3b31d023b67f6d8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 IncomingDataQueue::getMinValidPacketSequence </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimun number of consecutive packets that must be received from a source before accepting its data packets. </p>

</div>
</div>
<a class="anchor" id="ac884b9005077f3320e6b9b5fc3694589"></a><!-- doxytag: member="IncomingDataQueue::getNextDataPacketSize" ref="ac884b9005077f3320e6b9b5fc3694589" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IncomingDataQueue::getNextDataPacketSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="class_r_t_p_duplex.html#ad23a35fc2e42bb04d354fe8c8c9b2471">RTPDuplex</a>.</p>

</div>
</div>
<a class="anchor" id="a93207595215c402ce706d01448a9dacf"></a><!-- doxytag: member="IncomingDataQueue::getWaiting" ref="a93207595215c402ce706d01448a9dacf" args="(uint32 timestamp, const SyncSource *src=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingDataQueue::IncomingRTPPktLink</a>* IncomingDataQueue::getWaiting </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sync_source.html">SyncSource</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is used to fetch a packet in the receive queue and to expire packets older than the current timestamp. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>packet buffer object for current timestamp if found. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>timestamp requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>optional source selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>if found, the packet is removed from the reception queue </dd></dl>

</div>
</div>
<a class="anchor" id="a09b23b4a1cac969a663a7f64cd45f7d3"></a><!-- doxytag: member="IncomingDataQueue::insertRecvPacket" ref="a09b23b4a1cac969a663a7f64cd45f7d3" args="(IncomingRTPPktLink *packetLink)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IncomingDataQueue::insertRecvPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> *&nbsp;</td>
          <td class="paramname"> <em>packetLink</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a just received packet in the queue (both general and source specific queues). </p>
<p>If the packet was already in the queue (same SSRC and sequence number), it is not inserted but deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packetLink</em>&nbsp;</td><td>link to a packet just received and generally validated and processed by onRTPPacketRecv.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether the packet was successfully inserted. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>when the packet is duplicated (there is already a packet from the same source with the same timestamp). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>when the packet is not duplicated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb51f4a1018fed3e2e25937a03cedde2"></a><!-- doxytag: member="IncomingDataQueue::isWaiting" ref="aeb51f4a1018fed3e2e25937a03cedde2" args="(const SyncSource *src=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IncomingDataQueue::isWaiting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sync_source.html">SyncSource</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if packets are waiting in the reception queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Optional synchronization source selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if packets are waiting. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d1fda86e7bf629ccb2fbc85a0edb27f"></a><!-- doxytag: member="IncomingDataQueue::onExpireRecv" ref="a5d1fda86e7bf629ccb2fbc85a0edb27f" args="(IncomingRTPPkt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IncomingDataQueue::onExpireRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A hook to filter packets in the receive queue that are being expired. </p>
<p>This hook may be used to do some application specific processing on expired packets before they are deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-</em>&nbsp;</td><td>packet expired from the recv queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b75da6823836f59673bafaa6b3859c4"></a><!-- doxytag: member="IncomingDataQueue::onNewSyncSource" ref="a7b75da6823836f59673bafaa6b3859c4" args="(const SyncSource &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IncomingDataQueue::onNewSyncSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sync_source.html">SyncSource</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Virtual called when a new synchronization source has joined the session. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-</em>&nbsp;</td><td>new synchronization source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab85042be854f1a366627f0ab3f5b800d"></a><!-- doxytag: member="IncomingDataQueue::onRTPPacketRecv" ref="ab85042be854f1a366627f0ab3f5b800d" args="(IncomingRTPPkt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IncomingDataQueue::onRTPPacketRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A virtual function to support parsing of arriving packets to determine if they should be kept in the queue and to dispatch events. </p>
<p>A generic header validity check (as specified in RFC 1889) is performed on every incoming packet. If the generic check completes succesfully, this method is called before the packet is actually inserted into the reception queue.</p>
<p>May be used to perform additional validity checks or to do some application specific processing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-</em>&nbsp;</td><td>packet just received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if packet is kept in the incoming packets queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c3bfb8ae52bda2bff43f62784cf24d5"></a><!-- doxytag: member="IncomingDataQueue::onSRTPPacketError" ref="a9c3bfb8ae52bda2bff43f62784cf24d5" args="(IncomingRTPPkt &amp;pkt, int32 errorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IncomingDataQueue::onSRTPPacketError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A hook that gets called if the decoding of an incoming SRTP was erroneous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The SRTP packet with error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorCode</em>&nbsp;</td><td>The error code: -1 - SRTP authentication failure, -2 - replay check failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True: put the packet in incoming queue for further processing by the applications; false: dismiss packet. The default implementation returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="ab247b353020527a917db9aaba5bb5dde"></a><!-- doxytag: member="IncomingDataQueue::purgeIncomingQueue" ref="ab247b353020527a917db9aaba5bb5dde" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::purgeIncomingQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33827293af289391ecb1b227aac14158"></a><!-- doxytag: member="IncomingDataQueue::recordExtraction" ref="a33827293af289391ecb1b227aac14158" args="(const IncomingRTPPkt &amp;pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::recordExtraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Log extraction of a packet from this source from the scheduled reception queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>Packet extracted from the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a628cb3c8b6f4f0b31952aa9138105c69"></a><!-- doxytag: member="IncomingDataQueue::recordReception" ref="a628cb3c8b6f4f0b31952aa9138105c69" args="(SyncSourceLink &amp;srcLink, const IncomingRTPPkt &amp;pkt, const timeval recvtime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IncomingDataQueue::recordReception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_membership_bookkeeping_1_1_sync_source_link.html">SyncSourceLink</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_incoming_r_t_p_pkt.html">IncomingRTPPkt</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval&nbsp;</td>
          <td class="paramname"> <em>recvtime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Log reception of a new RTP packet from this source. </p>
<p>Usually updates data such as the packet counter, the expected sequence number for the next packet and the time the last packet was received at.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srcLink</em>&nbsp;</td><td>Link structure for the synchronization source of this packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>Packet just created and to be logged. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recvtime</em>&nbsp;</td><td>Reception time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether, according to the source state and statistics, the packet is considered valid and must be inserted in the incoming packets queue. </dd></dl>

</div>
</div>
<a class="anchor" id="aea541eb5abb237557d63d131160ce5f0"></a><!-- doxytag: member="IncomingDataQueue::recvData" ref="aea541eb5abb237557d63d131160ce5f0" args="(unsigned char *buffer, size_t length, InetHostAddress &amp;host, tpport_t &amp;port)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IncomingDataQueue::recvData </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InetHostAddress &amp;&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tpport_t &amp;&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs the physical I/O for reading a packet from the source. </p>
<p>It is a virtual that is overriden in the derived class.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes read. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>of read packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>of data to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>host</em>&nbsp;</td><td>address of source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>number of source. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_r_t_p_duplex.html#abb5f6c2e9c218c0cf1ab40d1ffae24ad">RTPDuplex</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0b5cbed6adb254d3c72081b47daa5e"></a><!-- doxytag: member="IncomingDataQueue::removeInQueueCryptoContext" ref="a9c0b5cbed6adb254d3c72081b47daa5e" args="(CryptoContext *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::removeInQueueCryptoContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_crypto_context.html">CryptoContext</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a>. </p>
<p>The endQueue method (provided by RTPQueue) also deletes all registered CryptoContexts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>Pointer to initialized <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a> to remove. If pointer if <code>NULL</code> then delete the whole queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a8b5c6c0e3c934cece8e909a499efd6"></a><!-- doxytag: member="IncomingDataQueue::renewLocalSSRC" ref="a7a8b5c6c0e3c934cece8e909a499efd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::renewLocalSSRC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_r_t_p_queue_base.html#ad05d8b02c9a90d36401262bf309e7f8e">RTPQueueBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_r_t_p_data_queue.html#a3cda7f313b23c9e00df8e54ed091e6a7">RTPDataQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a77098469cdf43464c881e1e4087f9465"></a><!-- doxytag: member="IncomingDataQueue::setInQueueCryptoContext" ref="a77098469cdf43464c881e1e4087f9465" args="(CryptoContext *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::setInQueueCryptoContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_crypto_context.html">CryptoContext</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set input queue <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a>. </p>
<p>The endQueue method (provided by RTPQueue) deletes all registered CryptoContexts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>Pointer to initialized <a class="el" href="class_crypto_context.html" title="The implementation for a SRTP cryptographic context.">CryptoContext</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a731b655bf21873cfe3d24cff51c9c399"></a><!-- doxytag: member="IncomingDataQueue::setMaxPacketDropout" ref="a731b655bf21873cfe3d24cff51c9c399" args="(uint16 packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::setMaxPacketDropout </td>
          <td>(</td>
          <td class="paramtype">uint16&nbsp;</td>
          <td class="paramname"> <em>packets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>It also prevents packets sent after a restart of the source being immediately accepted. </p>

</div>
</div>
<a class="anchor" id="a602ef8706aa0b5fb2fcee2695b7be98d"></a><!-- doxytag: member="IncomingDataQueue::setMaxPacketMisorder" ref="a602ef8706aa0b5fb2fcee2695b7be98d" args="(uint16 packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::setMaxPacketMisorder </td>
          <td>(</td>
          <td class="paramtype">uint16&nbsp;</td>
          <td class="paramname"> <em>packets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67c0dd360533faeaf3bd317fdf5fb8e3"></a><!-- doxytag: member="IncomingDataQueue::setMinValidPacketSequence" ref="a67c0dd360533faeaf3bd317fdf5fb8e3" args="(uint8 packets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::setMinValidPacketSequence </td>
          <td>(</td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>packets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When receiving packets from a new source, it may be convenient to reject a first few packets before we are really sure the source is valid. </p>
<p>This method sets how many data packets must be received in sequence before the source is considered valid and the stack starts to accept its packets.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the default (see <a class="el" href="class_incoming_data_queue.html#afd2b5c6ec4ef8eab87645a3cad177bd1">defaultMinValidPacketSequence()</a>) value for this parameter is 0, so that no packets are rejected (data packets are accepted from the first one).</dd>
<dd>
this validation is performed after the generic header validation and the additional validation done in <a class="el" href="class_incoming_data_queue.html#ab85042be854f1a366627f0ab3f5b800d" title="A virtual function to support parsing of arriving packets to determine if they should...">onRTPPacketRecv()</a>.</dd>
<dd>
if any valid RTCP packet is received from this source, it will be immediatly considered valid regardless of the number of sequential data packets received.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>number of sequential packet required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c595148215e5bf4098ff0e13d1ccfb7"></a><!-- doxytag: member="IncomingDataQueue::setSourceExpirationPeriod" ref="a6c595148215e5bf4098ff0e13d1ccfb7" args="(uint8 intervals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncomingDataQueue::setSourceExpirationPeriod </td>
          <td>(</td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>intervals</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number of RTCP intervals that the stack will wait to change the state of a source from stateActive to stateInactive, or to delete the source after being in stateInactive. </p>
<p>Note that this value should be uniform accross all participants and SHOULD be fixed for a particular profile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intervals</em>&nbsp;</td><td>number of RTCP report intervals</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If RTCP is not being used, the RTCP interval is assumed to be the default: 5 seconds. </dd>
<dd>
The default for this value is, as RECOMMENDED, 5. </dd></dl>

</div>
</div>
<a class="anchor" id="afd2073e2efcf4843a54a710ff543643f"></a><!-- doxytag: member="IncomingDataQueue::takeInDataPacket" ref="afd2073e2efcf4843a54a710ff543643f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IncomingDataQueue::takeInDataPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used by the service thread to process the next incoming packet and place it in the receive list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of payload bytes received. &lt;0 if error. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aff53fe9c29f8c092b9bfbad60934d420"></a><!-- doxytag: member="IncomingDataQueue::cryptoContexts" ref="aff53fe9c29f8c092b9bfbad60934d420" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_crypto_context.html">CryptoContext</a> *&gt; <a class="el" href="class_incoming_data_queue.html#aff53fe9c29f8c092b9bfbad60934d420">IncomingDataQueue::cryptoContexts</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a963d974350fd1482bcd2e53ed9821afe"></a><!-- doxytag: member="IncomingDataQueue::cryptoMutex" ref="a963d974350fd1482bcd2e53ed9821afe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mutex <a class="el" href="class_incoming_data_queue.html#a963d974350fd1482bcd2e53ed9821afe">IncomingDataQueue::cryptoMutex</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03c2083686a6352960ea364ff0247c0b"></a><!-- doxytag: member="IncomingDataQueue::defaultMaxPacketDropout" ref="a03c2083686a6352960ea364ff0247c0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16 <a class="el" href="class_incoming_data_queue.html#a03c2083686a6352960ea364ff0247c0b">IncomingDataQueue::defaultMaxPacketDropout</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8620d1560ddb2450505b06f3ab488698"></a><!-- doxytag: member="IncomingDataQueue::defaultMaxPacketMisorder" ref="a8620d1560ddb2450505b06f3ab488698" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16 <a class="el" href="class_incoming_data_queue.html#a8620d1560ddb2450505b06f3ab488698">IncomingDataQueue::defaultMaxPacketMisorder</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01202d358cef0bf703b2991236b15c9e"></a><!-- doxytag: member="IncomingDataQueue::defaultMembersSize" ref="a01202d358cef0bf703b2991236b15c9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="class_incoming_data_queue.html#a01202d358cef0bf703b2991236b15c9e">IncomingDataQueue::defaultMembersSize</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd2b5c6ec4ef8eab87645a3cad177bd1"></a><!-- doxytag: member="IncomingDataQueue::defaultMinValidPacketSequence" ref="afd2b5c6ec4ef8eab87645a3cad177bd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8 <a class="el" href="class_incoming_data_queue.html#afd2b5c6ec4ef8eab87645a3cad177bd1">IncomingDataQueue::defaultMinValidPacketSequence</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aadcc24fdfc96c87f0dfa7c3b6a9c64e8"></a><!-- doxytag: member="IncomingDataQueue::maxPacketDropout" ref="aadcc24fdfc96c87f0dfa7c3b6a9c64e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 <a class="el" href="class_incoming_data_queue.html#aadcc24fdfc96c87f0dfa7c3b6a9c64e8">IncomingDataQueue::maxPacketDropout</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a425682bbc96cc0401aafffea0fd59bbd"></a><!-- doxytag: member="IncomingDataQueue::maxPacketMisorder" ref="a425682bbc96cc0401aafffea0fd59bbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 <a class="el" href="class_incoming_data_queue.html#a425682bbc96cc0401aafffea0fd59bbd">IncomingDataQueue::maxPacketMisorder</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f5902996f89705f0d85df36a9778787"></a><!-- doxytag: member="IncomingDataQueue::minValidPacketSequence" ref="a7f5902996f89705f0d85df36a9778787" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 <a class="el" href="class_incoming_data_queue.html#a7f5902996f89705f0d85df36a9778787">IncomingDataQueue::minValidPacketSequence</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a93562ccedcba87b2abf91f890868cab6"></a><!-- doxytag: member="IncomingDataQueue::recvFirst" ref="a93562ccedcba87b2abf91f890868cab6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a>* <a class="el" href="class_incoming_data_queue.html#a93562ccedcba87b2abf91f890868cab6">IncomingDataQueue::recvFirst</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d5fc37470fbf038b374664dcfc96435"></a><!-- doxytag: member="IncomingDataQueue::recvLast" ref="a5d5fc37470fbf038b374664dcfc96435" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_membership_bookkeeping_1_1_incoming_r_t_p_pkt_link.html">IncomingRTPPktLink</a> * <a class="el" href="class_incoming_data_queue.html#a5d5fc37470fbf038b374664dcfc96435">IncomingDataQueue::recvLast</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adccf839d9a491cdf98fb2f4f3e13d5d7"></a><!-- doxytag: member="IncomingDataQueue::recvLock" ref="adccf839d9a491cdf98fb2f4f3e13d5d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadLock <a class="el" href="class_incoming_data_queue.html#adccf839d9a491cdf98fb2f4f3e13d5d7">IncomingDataQueue::recvLock</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d59b8ffbf0b1951e294650ab2a8ef8f"></a><!-- doxytag: member="IncomingDataQueue::sourceExpirationPeriod" ref="a8d59b8ffbf0b1951e294650ab2a8ef8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 <a class="el" href="class_incoming_data_queue.html#a8d59b8ffbf0b1951e294650ab2a8ef8f">IncomingDataQueue::sourceExpirationPeriod</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="iqueue_8h_source.html">iqueue.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Sep 21 04:20:09 2010 for ccRTP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
