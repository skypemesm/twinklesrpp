<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ccRTP: RTPDataQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RTPDataQueue Class Reference<br/>
<small>
[<a class="el" href="group__ioqueue.html">Generic RTP input/output queues.</a>]</small>
</h1><!-- doxytag: class="RTPDataQueue" --><!-- doxytag: inherits="IncomingDataQueue,OutgoingDataQueue" -->
<p>A packet queue handler for building different kinds of RTP protocol systems.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ioqueue_8h_source.html">ioqueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTPDataQueue:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_r_t_p_data_queue.png" usemap="#RTPDataQueue_map" alt=""/>
  <map id="RTPDataQueue_map" name="RTPDataQueue_map">
<area href="class_incoming_data_queue.html" alt="IncomingDataQueue" shape="rect" coords="247,112,402,136"/>
<area href="class_outgoing_data_queue.html" alt="OutgoingDataQueue" shape="rect" coords="1072,112,1227,136"/>
<area href="class_incoming_data_queue_base.html" alt="IncomingDataQueueBase" shape="rect" coords="0,56,155,80"/>
<area href="class_membership_bookkeeping.html" alt="MembershipBookkeeping" shape="rect" coords="495,56,650,80"/>
<area href="class_outgoing_data_queue_base.html" alt="OutgoingDataQueueBase" shape="rect" coords="990,56,1145,80"/>
<area href="class_destination_list_handler.html" alt="DestinationListHandler" shape="rect" coords="1155,56,1310,80"/>
<area href="class_r_t_p_queue_base.html" alt="RTPQueueBase" shape="rect" coords="0,0,155,24"/>
<area href="class_sync_source_handler.html" alt="SyncSourceHandler" shape="rect" coords="165,0,320,24"/>
<area href="class_participant_handler.html" alt="ParticipantHandler" shape="rect" coords="330,0,485,24"/>
<area href="class_application_handler.html" alt="ApplicationHandler" shape="rect" coords="495,0,650,24"/>
<area href="class_conflict_handler.html" alt="ConflictHandler" shape="rect" coords="660,0,815,24"/>
<area href="class_members.html" alt="Members" shape="rect" coords="825,0,980,24"/>
<area href="class_r_t_p_queue_base.html" alt="RTPQueueBase" shape="rect" coords="990,0,1145,24"/>
<area href="class_queue_r_t_c_p_manager.html" alt="QueueRTCPManager" shape="rect" coords="577,224,732,248"/>
<area href="class_r_t_p_duplex.html" alt="RTPDuplex" shape="rect" coords="742,224,897,248"/>
<area href="class_a_v_p_queue.html" alt="AVPQueue" shape="rect" coords="577,280,732,304"/>
</map>
 </div>
</div>

<p><a href="class_r_t_p_data_queue-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1">Tos</a> { <a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1a6dc3c20fe1dd9d54192e897866e3768a">tosBestEffort</a>, 
<a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1ae36023f8f3626a08e501ba65e4fefc24">tosEnhanced</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><a class="el" href="rtp_8h.html" title="Generic and audio/video profile specific RTP interface of ccRTP.">rtp.h</a> cc++/rtp.h </p>
 <a href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a0edd2b1a8a22780b60da8eb05921ad16">setTypeOfService</a> (<a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1">Tos</a> tos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the kind of service the application expects to use.  <a href="#a0edd2b1a8a22780b60da8eb05921ad16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#afee8bf2e2943d8785352eef2b804a91d">enableStack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable packet queue processing in the stack.  <a href="#afee8bf2e2943d8785352eef2b804a91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#aa68b9d380c05c3c2c18ad6920aab9179">disableStack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable packet queue processing in the stack.  <a href="#aa68b9d380c05c3c2c18ad6920aab9179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a3d2531b75d7c79d815cff5c487d4ecc8">isActive</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get active connection state flag.  <a href="#a3d2531b75d7c79d815cff5c487d4ecc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#abf7ff6490ae207bd2588bc0c69f8034a">getCurrentTimestamp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the timestamp that should be given for a packet whose payload sampling instant corresponds to the current system time.  <a href="#abf7ff6490ae207bd2588bc0c69f8034a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#afa51bc8859fd4c7e5460caa31d8c518b">setSessionBandwidth</a> (uint32 bw)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the bandwidth of the current session.  <a href="#afa51bc8859fd4c7e5460caa31d8c518b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#aed0854a61cdd61dc2c6915d81da44d88">getDefaultSessionBandwidth</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a90a9016c723622f778aa9b078f400ab2">getSessionBandwidth</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a3c16280cc4b45de49acd61d0dc1f53b8">setTimeclock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the packet timeclock for synchronizing timestamps.  <a href="#a3c16280cc4b45de49acd61d0dc1f53b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">timeout_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a1007b5aceb1feb516cdd5bdd34318b6b">getTimeclock</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the packet timeclock for synchronizing timestamps.  <a href="#a1007b5aceb1feb516cdd5bdd34318b6b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a02a7fec519ec7c15650224e108959a62">RTPDataQueue</a> (uint32 size=<a class="el" href="class_membership_bookkeeping.html#a53ba5e9495dfdb9ec16c551206796d99">defaultMembersHashSize</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a02a7fec519ec7c15650224e108959a62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a767fd472543461067810641e8ce11bf3">RTPDataQueue</a> (uint32 *ssrc, uint32 size=<a class="el" href="class_membership_bookkeeping.html#a53ba5e9495dfdb9ec16c551206796d99">defaultMembersHashSize</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Using this constructor you can start a session with the given ssrc, instead of the usual randomly generated one.  <a href="#a767fd472543461067810641e8ce11bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a15ff7c0ccea0eb5749b60c4ef7d08f0d">~RTPDataQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The queue destructor flushes the queue and stops all services.  <a href="#a15ff7c0ccea0eb5749b60c4ef7d08f0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#ae9f0d6236da0cee4c6b5189c0daa633d">timerTick</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A plugin point for timer tick driven events.  <a href="#ae9f0d6236da0cee4c6b5189c0daa633d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a3cda7f313b23c9e00df8e54ed091e6a7">renewLocalSSRC</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a73039fed28d74fc6fdae60ecf94a0fe9">endQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method ends the queue.  <a href="#a73039fed28d74fc6fdae60ecf94a0fe9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_p_data_queue.html#a55e55a5fe67dfd3bec5ed7ea553b9c8d">isPendingData</a> (<a class="el" href="base_8h.html#ac16d853255145e6a903914eb376a84bb">microtimeout_t</a> timeout)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to check for and schedule against arriving packets based on the derived connection type.  <a href="#a55e55a5fe67dfd3bec5ed7ea553b9c8d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A packet queue handler for building different kinds of RTP protocol systems. </p>
<p>The queue manages both incoming and outgoing RTP packets, as well as synchronization and transmission/reception timers. By making the queue handler a seperate base class it becomes possible to define RTP classes for RTP profiles and sessions of different types.</p>
<p>Outgoing packets are sent via the <a class="el" href="class_outgoing_data_queue.html#ac47cec242d96bc326f0292890e570d64" title="This is used to create a data packet in the send queue.">OutgoingDataQueue::putData</a> method.</p>
<p>Incoming packets can be retrieved via <a class="el" href="class_incoming_data_queue.html#a830c8a49a36dcd3e30c4e98f15e8af14" title="Retreive data from a specific timestamped packet if such a packet is currently available...">IncomingDataQueue::getData</a> method.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>David Sugar &lt;<a href="mailto:dyfet@ostel.com">dyfet@ostel.com</a>&gt; RTP data queue handler. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afa5169fe853e891b04897fab6f8efca1"></a><!-- doxytag: member="RTPDataQueue::Tos" ref="afa5169fe853e891b04897fab6f8efca1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1">RTPDataQueue::Tos</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="rtp_8h.html" title="Generic and audio/video profile specific RTP interface of ccRTP.">rtp.h</a> cc++/rtp.h </p>
<p>Type of network service the application uses.</p>
<p>If the application uses enhanced network service, for instance Integrated Services or Differentiated Services, it <em>has not</em> to ensure fair competition with TCP, provided that the requested service is actually being delivered. Whenever the application uses best-effort service or the requested enhanced service is not actually being delivered, it <em>has</em> to ensure fair competition with TCP. By default, best-effot is assumed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Although not required, RTP packets are always sent on top of UDP segments. No other underlying transport protocol is supported at present.</dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afa5169fe853e891b04897fab6f8efca1a6dc3c20fe1dd9d54192e897866e3768a"></a><!-- doxytag: member="tosBestEffort" ref="afa5169fe853e891b04897fab6f8efca1a6dc3c20fe1dd9d54192e897866e3768a" args="" -->tosBestEffort</em>&nbsp;</td><td>
<p>Best-effort network service. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afa5169fe853e891b04897fab6f8efca1ae36023f8f3626a08e501ba65e4fefc24"></a><!-- doxytag: member="tosEnhanced" ref="afa5169fe853e891b04897fab6f8efca1ae36023f8f3626a08e501ba65e4fefc24" args="" -->tosEnhanced</em>&nbsp;</td><td>
<p>Enhanced network service. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02a7fec519ec7c15650224e108959a62"></a><!-- doxytag: member="RTPDataQueue::RTPDataQueue" ref="a02a7fec519ec7c15650224e108959a62" args="(uint32 size=defaultMembersHashSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTPDataQueue::RTPDataQueue </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code><a class="el" href="class_membership_bookkeeping.html#a53ba5e9495dfdb9ec16c551206796d99">defaultMembersHashSize</a></code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>This will generate a random application SSRC identifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>an estimation of the number of participants in the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a767fd472543461067810641e8ce11bf3"></a><!-- doxytag: member="RTPDataQueue::RTPDataQueue" ref="a767fd472543461067810641e8ce11bf3" args="(uint32 *ssrc, uint32 size=defaultMembersHashSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTPDataQueue::RTPDataQueue </td>
          <td>(</td>
          <td class="paramtype">uint32 *&nbsp;</td>
          <td class="paramname"> <em>ssrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code><a class="el" href="class_membership_bookkeeping.html#a53ba5e9495dfdb9ec16c551206796d99">defaultMembersHashSize</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Using this constructor you can start a session with the given ssrc, instead of the usual randomly generated one. </p>
<p>This is necessary when you need to initiate several sessions having the same SSRC identifier, for instance, to implement layered encoding, in which case each layer is managed through a different session but all sessions share the same SSRC identifier.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This doesn't seem to be a good solution</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ssrc</em>&nbsp;</td><td>Synchronization SouRCe identifier for this session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>an estimation of the number of participants in the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15ff7c0ccea0eb5749b60c4ef7d08f0d"></a><!-- doxytag: member="RTPDataQueue::~RTPDataQueue" ref="a15ff7c0ccea0eb5749b60c4ef7d08f0d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RTPDataQueue::~RTPDataQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The queue destructor flushes the queue and stops all services. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa68b9d380c05c3c2c18ad6920aab9179"></a><!-- doxytag: member="RTPDataQueue::disableStack" ref="aa68b9d380c05c3c2c18ad6920aab9179" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::disableStack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable packet queue processing in the stack. </p>

</div>
</div>
<a class="anchor" id="afee8bf2e2943d8785352eef2b804a91d"></a><!-- doxytag: member="RTPDataQueue::enableStack" ref="afee8bf2e2943d8785352eef2b804a91d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::enableStack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable packet queue processing in the stack. </p>
<p>This method will not any thread of execution. </p>

</div>
</div>
<a class="anchor" id="a73039fed28d74fc6fdae60ecf94a0fe9"></a><!-- doxytag: member="RTPDataQueue::endQueue" ref="a73039fed28d74fc6fdae60ecf94a0fe9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::endQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method ends the queue. </p>

</div>
</div>
<a class="anchor" id="abf7ff6490ae207bd2588bc0c69f8034a"></a><!-- doxytag: member="RTPDataQueue::getCurrentTimestamp" ref="abf7ff6490ae207bd2588bc0c69f8034a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 RTPDataQueue::getCurrentTimestamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the timestamp that should be given for a packet whose payload sampling instant corresponds to the current system time. </p>
<p>The timestamp applications should provide for each packet represents the sampling instant of its payload and should not be a reading of the system clock. Nevertheless, the internal operation of the RTP stack relies on the accuracy of the provided timestamp, since several computations assume that there is a certain degree of correspondence between the timestamp and the system clock.</p>
<p>It is recommended that applications use this method in order to <em>periodically adjust the RTP timestamp</em>.</p>
<p>In particular, it is advisable getting the timestamp corresponding to the first sampling instant or any instant after a period of inactivity through a call to this method.</p>
<p>Applications should use the nominal sampling or any other value provided by the coder in order to compute the next timestamps with minimum computational requirement.</p>
<p>For instance, an application using an RTP profile that specifies a fixed sampling rate of 8 Khz with eight bits per sample, continuously transmitting audio blocks 80 octets long, would transmit 100 packets every second. Every packet would carry a timestamp 80 units greater than the previous one. So, the first timestamp would be obtained from this method, whereas the following ones would be computed adding 80 every time. Also the timestamp should be increased for every block whether it is put in the queue or dropped.</p>
<p>The aforementioned increment can be obtained from the RTPDataQueue::getTimestampIncrement() method rather than computing it by hand in the application.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Frame based applications must follow a specific timestamping method, probably specified in a profile.</dd>
<dd>
You should take into account that by default ccRTP assumes that the application begins sampling at the queue creation time. Moreover, the first sampling instant is assigned a "user visible" timestamp of 0, although the RTP stack will then add internally a ramdom offset unknown to the application. That is to say, the application may count samples from 0 in order to get the timestamp for the next packet, provided that the first sampling instant is the same as the queue creation time. Nevertheless, this simpler way of starting will not be as accurate as it would be if the application got at least the first timestamp through getCurrentTimestamp. <em>We provide this option since ccRTP interface is evolving, but we admit that it is ugly, we could remove this option or even replace uint32 timestamps with a restrictively regulated object; suggestions are gladly welcomed</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aed0854a61cdd61dc2c6915d81da44d88"></a><!-- doxytag: member="RTPDataQueue::getDefaultSessionBandwidth" ref="aed0854a61cdd61dc2c6915d81da44d88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 RTPDataQueue::getDefaultSessionBandwidth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a90a9016c723622f778aa9b078f400ab2"></a><!-- doxytag: member="RTPDataQueue::getSessionBandwidth" ref="a90a9016c723622f778aa9b078f400ab2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 RTPDataQueue::getSessionBandwidth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1007b5aceb1feb516cdd5bdd34318b6b"></a><!-- doxytag: member="RTPDataQueue::getTimeclock" ref="a1007b5aceb1feb516cdd5bdd34318b6b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">timeout_t RTPDataQueue::getTimeclock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the packet timeclock for synchronizing timestamps. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>runtime in milliseconds since last set. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d2531b75d7c79d815cff5c487d4ecc8"></a><!-- doxytag: member="RTPDataQueue::isActive" ref="a3d2531b75d7c79d815cff5c487d4ecc8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTPDataQueue::isActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get active connection state flag. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if connection "active". </dd></dl>

</div>
</div>
<a class="anchor" id="a55e55a5fe67dfd3bec5ed7ea553b9c8d"></a><!-- doxytag: member="RTPDataQueue::isPendingData" ref="a55e55a5fe67dfd3bec5ed7ea553b9c8d" args="(microtimeout_t timeout)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTPDataQueue::isPendingData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#ac16d853255145e6a903914eb376a84bb">microtimeout_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to check for and schedule against arriving packets based on the derived connection type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if packet waiting for processing. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of microseconds to wait. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_r_t_p_duplex.html#a48eea122a1f60c696a5b181ee56ceeef">RTPDuplex</a>.</p>

</div>
</div>
<a class="anchor" id="a3cda7f313b23c9e00df8e54ed091e6a7"></a><!-- doxytag: member="RTPDataQueue::renewLocalSSRC" ref="a3cda7f313b23c9e00df8e54ed091e6a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::renewLocalSSRC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_incoming_data_queue.html#a7a8b5c6c0e3c934cece8e909a499efd6">IncomingDataQueue</a>.</p>

</div>
</div>
<a class="anchor" id="afa51bc8859fd4c7e5460caa31d8c518b"></a><!-- doxytag: member="RTPDataQueue::setSessionBandwidth" ref="afa51bc8859fd4c7e5460caa31d8c518b" args="(uint32 bw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::setSessionBandwidth </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>bw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the bandwidth of the current session. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bw</em>&nbsp;</td><td>bandwidth of the current session, in bits/s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_a_v_p_queue.html#a3fd139decfd1175b7ad6a8abeed65bf5" title="Specify the bandwith available for control (RTCP) packets.">AVPQueue::setControlBandwidth()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c16280cc4b45de49acd61d0dc1f53b8"></a><!-- doxytag: member="RTPDataQueue::setTimeclock" ref="a3c16280cc4b45de49acd61d0dc1f53b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::setTimeclock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the packet timeclock for synchronizing timestamps. </p>

</div>
</div>
<a class="anchor" id="a0edd2b1a8a22780b60da8eb05921ad16"></a><!-- doxytag: member="RTPDataQueue::setTypeOfService" ref="a0edd2b1a8a22780b60da8eb05921ad16" args="(Tos tos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTPDataQueue::setTypeOfService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_p_data_queue.html#afa5169fe853e891b04897fab6f8efca1">Tos</a>&nbsp;</td>
          <td class="paramname"> <em>tos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the kind of service the application expects to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tos</em>&nbsp;</td><td>type of service the application expects to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If enhanced service is specified but packet loss is high (the requested service does not appear to actually be delivered) ccRTP defaults to best-effort suitable behaviour: guarantee fair competition with TCP.</dd></dl>

</div>
</div>
<a class="anchor" id="ae9f0d6236da0cee4c6b5189c0daa633d"></a><!-- doxytag: member="RTPDataQueue::timerTick" ref="ae9f0d6236da0cee4c6b5189c0daa633d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTPDataQueue::timerTick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A plugin point for timer tick driven events. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ioqueue_8h_source.html">ioqueue.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Sep 21 04:20:10 2010 for ccRTP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
