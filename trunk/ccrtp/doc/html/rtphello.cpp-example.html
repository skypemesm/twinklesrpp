<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ccRTP: rtphello.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>rtphello.cpp</h1><p>A basic example of how to use <a class="el" href="class_r_t_p_packet.html" title="A base class for both IncomingRTPPkt and OutgoingRTPPkt.">RTPPacket</a></p>
<div class="fragment"><pre class="fragment"><span class="comment">// rtphello</span>
<span class="comment">// A very simple program for testing and illustrating basic features of ccRTP.</span>
<span class="comment">// Copyright (C) 2001,2002  Federico Montesino &lt;fedemp@altern.org&gt;</span>
<span class="comment">//  </span>
<span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<span class="comment">// it under the terms of the GNU General Public License as published by</span>
<span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment">// (at your option) any later version.</span>
<span class="comment">//  </span>
<span class="comment">// This program is distributed in the hope that it will be useful,</span>
<span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment">// GNU General Public License for more details.</span>
<span class="comment">//  </span>
<span class="comment">// You should have received a copy of the GNU General Public License</span>
<span class="comment">// along with this program; if not, write to the Free Software</span>
<span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>


<span class="comment">// This is an introductory example file that illustrates basic usage</span>
<span class="comment">// of ccRTP. You will also see a bit on how to use other classes from</span>
<span class="comment">// CommonC++.</span>

<span class="comment">// I am a typical hello world program. I consist of a sender thread,</span>
<span class="comment">// that sends the salutation message on RTP packets; and a receiver</span>
<span class="comment">// thread, that prints the messages. This is a program with an unsual</span>
<span class="comment">// structure, the receiver just tries to process the first available</span>
<span class="comment">// packet periodically, and both are in the same program. Thus, it</span>
<span class="comment">// should not be seen as an example for typical applications but as a</span>
<span class="comment">// test of some functions of ccRTP.</span>

<span class="preprocessor">#include &lt;cstdio&gt;</span>
<span class="preprocessor">#include &lt;ctime&gt;</span>
<span class="comment">// In order to use ccRTP, the RTP stack of CommonC++, just include...</span>
<span class="preprocessor">#include &lt;<a class="code" href="rtp_8h.html" title="Generic and audio/video profile specific RTP interface of ccRTP.">ccrtp/rtp.h</a>&gt;</span>

<span class="preprocessor">#ifdef  CCXX_NAMESPACES</span>
<span class="preprocessor"></span><span class="keyword">using namespace </span>ost;
<span class="keyword">using namespace </span>std;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// base ports</span>
<span class="keyword">const</span> <span class="keywordtype">int</span> RECEIVER_BASE = 33634;
<span class="keyword">const</span> <span class="keywordtype">int</span> TRANSMITTER_BASE = 32522;

<span class="comment">// For this example, this is irrelevant. </span>
<span class="comment">//const int TIMESTAMP_RATE = 90000;</span>

<span class="keyword">class </span>ccRTP_Hello_Rx: <span class="keyword">public</span> Thread
{

<span class="keyword">private</span>:
        <span class="comment">// socket to receive packets</span>
        <a name="_a0"></a><a class="code" href="class_single_thread_r_t_p_session.html" title="This template class adds the threading aspect to the RTPSessionBase template in one...">RTPSession</a> *socket;
        <span class="comment">// loopback network address</span>
        InetHostAddress local_ip;
        <span class="comment">// identifier of this sender</span>
        uint32 ssrc;
        
<span class="keyword">public</span>:
        ccRTP_Hello_Rx(){
                <span class="comment">// Before using ccRTP you should learn something about other</span>
                <span class="comment">// CommonC++ classes. We need InetHostAddress...</span>

                <span class="comment">// Construct loopback address</span>
                local_ip = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;

                <span class="comment">// Is that correct?</span>
                <span class="keywordflow">if</span>( ! local_ip ){  
                        <span class="comment">// this is equivalent to `! local_ip.isInetAddress()&#39;</span>
                        cerr &lt;&lt; <span class="stringliteral">&quot;Rx: IP address is not correct!&quot;</span> &lt;&lt; endl;
                        exit();
                }

                <span class="comment">// create socket for RTP connection and get a random</span>
                <span class="comment">// SSRC identifier</span>
                socket = <span class="keyword">new</span> <a name="a1"></a><a class="code" href="group__sessions.html#ga24e16f350c9ae0c1e2a3f5d6a6dad9f9" title="Uses two pairs of sockets for RTP data and RTCP transmission/reception.">RTPSession</a>(local_ip,RECEIVER_BASE);
                ssrc = socket-&gt;getLocalSSRC();
        }
        
        ~ccRTP_Hello_Rx(){
                cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Destroying receiver -ID: &quot;</span> &lt;&lt; hex
                     &lt;&lt; (int)ssrc;
                terminate();
                <span class="keyword">delete</span> socket;
                cout &lt;&lt; <span class="stringliteral">&quot;... &quot;</span> &lt;&lt; <span class="stringliteral">&quot;destroyed.&quot;</span>;
        }

        <span class="comment">// This method does almost everything.</span>
        <span class="keywordtype">void</span> run(<span class="keywordtype">void</span>){    

                cout &lt;&lt; <span class="stringliteral">&quot;Hello, &quot;</span> &lt;&lt; <a name="a2"></a><a class="code" href="group__sources.html#ga206420a8423d0c261e9bfc5a388a9534" title="Get the RTPApplication object for the &amp;quot;default&amp;quot; application (the only one...">defaultApplication</a>().
                        getSDESItem(<a name="a3"></a><a class="code" href="group__rtcppacket.html#ggaf6d38e5ccbbcdf2a24ebbd4fc5b4eeaca56818aeaa2d578ab0055a59b8d8d28f9" title="Canonical end-point identifier.">SDESItemTypeCNAME</a>)
                     &lt;&lt; <span class="stringliteral">&quot; ...&quot;</span> &lt;&lt; endl;
                <span class="comment">// redefined from Thread.</span>
                <span class="comment">// Set up connection</span>
                socket-&gt;setSchedulingTimeout(20000);
                socket-&gt;setExpireTimeout(3000000);
                <span class="comment">//socket-&gt;UDPTransmit::setTypeOfService(SOCKET_IPTOS_LOWDELAY);</span>
                <span class="keywordflow">if</span>( !socket-&gt;addDestination(local_ip,TRANSMITTER_BASE) )
                        cerr &lt;&lt; <span class="stringliteral">&quot;Rx (&quot;</span> &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)ssrc 
                             &lt;&lt; <span class="stringliteral">&quot;): could not connect to port.&quot;</span> 
                             &lt;&lt; TRANSMITTER_BASE;
                
                cout &lt;&lt; <span class="stringliteral">&quot;Rx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc
                     &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; local_ip.getHostname() 
                     &lt;&lt; <span class="stringliteral">&quot; is waiting for salutes in port &quot;</span>
                     &lt;&lt; RECEIVER_BASE &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;
                
                socket-&gt;setPayloadFormat(<a name="_a4"></a><a class="code" href="class_static_payload_format.html" title="Static payload format objects.">StaticPayloadFormat</a>(<a name="a5"></a><a class="code" href="group__payload.html#gga7644623ce29b8ca519d7e3f276b6ddc6a3f5b07dca910f599be16c871ebbb29d1" title="MPEG 2 Transport stream (RFCs 1890, 2250).">sptMP2T</a>));
                socket-&gt;startRunning();
                <span class="comment">// Let&#39;s check the queues  (you should read the documentation</span>
                <span class="comment">// so that you know what the queues are for).</span>
                cout &lt;&lt; <span class="stringliteral">&quot;Rx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc 
                     &lt;&lt; <span class="stringliteral">&quot;): The queue is &quot;</span> 
                     &lt;&lt; ( socket-&gt;isActive() ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;in&quot;</span>) 
                     &lt;&lt; <span class="stringliteral">&quot;active.&quot;</span> &lt;&lt; endl;              

                <span class="comment">// This is the main loop, where packets are received.</span>
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0 ; true ; i++ ){
                        
                        <span class="comment">// Wait for an RTP packet.</span>
                        <span class="keyword">const</span> <a name="_a6"></a><a class="code" href="class_app_data_unit.html" title="Interface (envelope) to data received over RTP packets.">AppDataUnit</a> *adu = NULL;
                        <span class="keywordflow">while</span> ( NULL == adu ) {
                                Thread::sleep(10);
                                adu = socket-&gt;<a name="a7"></a><a class="code" href="class_app_data_unit.html#abe15787e1cc84dd03b0769a5546d7a38" title="Get data as it is received in RTP packets (i.e.">getData</a>(socket-&gt;getFirstTimestamp());
                        }
                        
                        <span class="comment">// Print content (likely a salute :))</span>
                        <span class="comment">// Note we are sure the data is an asciiz string.</span>
                        time_t receiving_time = time(NULL);
                        <span class="keywordtype">char</span> tmstring[30];
                        strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,localtime(&amp;receiving_time));
                        cout &lt;&lt; <span class="stringliteral">&quot;Rx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc 
                             &lt;&lt; <span class="stringliteral">&quot;): [receiving at &quot;</span> &lt;&lt; tmstring &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> 
                             &lt;&lt; adu-&gt;<a class="code" href="class_app_data_unit.html#abe15787e1cc84dd03b0769a5546d7a38" title="Get data as it is received in RTP packets (i.e.">getData</a>() &lt;&lt; endl;
                        <span class="keyword">delete</span> adu;
                }
        }
};

<span class="keyword">class </span>ccRTP_Hello_Tx: <span class="keyword">public</span> Thread, <span class="keyword">public</span> TimerPort
{

<span class="keyword">private</span>:
        <span class="comment">// socket to transmit</span>
        <a class="code" href="class_single_thread_r_t_p_session.html" title="This template class adds the threading aspect to the RTPSessionBase template in one...">RTPSession</a> *socket;
        <span class="comment">// loopback network address</span>
        InetHostAddress local_ip;
        <span class="comment">// identifier of this sender</span>
        uint32 ssrc;

<span class="keyword">public</span>:
        ccRTP_Hello_Tx(){
                <span class="comment">// Before using ccRTP you should learn something about other</span>
                <span class="comment">// CommonC++ classes. We need InetHostAddress...</span>

                <span class="comment">// Construct loopback address</span>
                local_ip = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;
                
                <span class="comment">// Is that correct?</span>
                <span class="keywordflow">if</span>( ! local_ip ){  
                <span class="comment">// this is equivalent to `! local_ip.isInetAddress()&#39;</span>
                        cerr &lt;&lt; <span class="stringliteral">&quot;Tx: IP address is not correct!&quot;</span> &lt;&lt; endl;
                        exit();
                }
                
                socket = <span class="keyword">new</span> <a class="code" href="group__sessions.html#ga24e16f350c9ae0c1e2a3f5d6a6dad9f9" title="Uses two pairs of sockets for RTP data and RTCP transmission/reception.">RTPSession</a>(local_ip,TRANSMITTER_BASE);
                ssrc = socket-&gt;getLocalSSRC();
        }

        ~ccRTP_Hello_Tx(){
                cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Destroying transmitter -ID: &quot;</span> &lt;&lt; hex 
                     &lt;&lt; (int)ssrc;
                terminate();
                <span class="keyword">delete</span> socket;
                cout &lt;&lt; <span class="stringliteral">&quot;... &quot;</span> &lt;&lt; <span class="stringliteral">&quot;destroyed.&quot;</span>;
        }

        <span class="comment">// This method does almost everything.</span>
        <span class="keywordtype">void</span> run(<span class="keywordtype">void</span>){    
                <span class="comment">// redefined from Thread.</span>
                cout &lt;&lt; <span class="stringliteral">&quot;Tx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; 
                        local_ip.getHostname() 
                     &lt;&lt; <span class="stringliteral">&quot; is going to salute perself through &quot;</span> 
                     &lt;&lt; local_ip &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;
                
                <span class="comment">// Set up connection</span>
                socket-&gt;setSchedulingTimeout(20000);
                socket-&gt;setExpireTimeout(3000000);
                <span class="keywordflow">if</span>( !socket-&gt;addDestination(local_ip,RECEIVER_BASE) )
                        cerr &lt;&lt; <span class="stringliteral">&quot;Tx (&quot;</span> &lt;&lt; hex &lt;&lt; (<span class="keywordtype">int</span>)ssrc 
                             &lt;&lt; <span class="stringliteral">&quot;): could not connect to port.&quot;</span> 
                             &lt;&lt; RECEIVER_BASE;
                
                cout &lt;&lt; <span class="stringliteral">&quot;Tx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc &lt;&lt; 
                        <span class="stringliteral">&quot;): Transmitting salutes to port &quot;</span>
                     &lt;&lt; RECEIVER_BASE &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;

                uint32 timestamp = 0;
                <span class="comment">// This will be useful for periodic execution</span>
                TimerPort::setTimer(1000);

                <span class="comment">// This is the main loop, where packets are sent.</span>
                socket-&gt;setPayloadFormat(<a class="code" href="class_static_payload_format.html" title="Static payload format objects.">StaticPayloadFormat</a>(<a class="code" href="group__payload.html#gga7644623ce29b8ca519d7e3f276b6ddc6a3f5b07dca910f599be16c871ebbb29d1" title="MPEG 2 Transport stream (RFCs 1890, 2250).">sptMP2T</a>));
                socket-&gt;startRunning();
                <span class="comment">// Let&#39;s check the queues  (you should read the documentation</span>
                <span class="comment">// so that you know what the queues are for).</span>
                cout &lt;&lt; <span class="stringliteral">&quot;Tx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc &lt;&lt; <span class="stringliteral">&quot;): The queue is &quot;</span>
                     &lt;&lt; ( socket-&gt;isActive()? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;in&quot;</span>)
                     &lt;&lt; <span class="stringliteral">&quot;active.&quot;</span> &lt;&lt; endl;

                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0 ; true ;i++ ){

                        <span class="comment">// send RTP packets, providing timestamp,</span>
                        <span class="comment">// payload type and payload.  </span>
                        <span class="comment">// construct salute.</span>
                        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> salute[50];
                        snprintf((<span class="keywordtype">char</span> *)salute,50,
                                 <span class="stringliteral">&quot;Hello, brave gnu world (#%u)!&quot;</span>,i);
                        time_t sending_time = time(NULL);
                        <span class="comment">// get timestamp to send salute</span>
                        <span class="keywordflow">if</span> ( 0 == i ){
                                timestamp = socket-&gt;getCurrentTimestamp();
                                
                        } <span class="keywordflow">else</span> {
                                <span class="comment">// increment for 1 second</span>
                                timestamp += socket-&gt;getCurrentRTPClockRate();
                        }       

                        socket-&gt;putData(timestamp,salute,
                                        strlen((<span class="keywordtype">char</span> *)salute)+1);
                        <span class="comment">// print info</span>
                        <span class="keywordtype">char</span> tmstring[30];
                        strftime(tmstring,30,<span class="stringliteral">&quot;%X&quot;</span>,
                                 localtime(&amp;sending_time));
                        cout &lt;&lt; <span class="stringliteral">&quot;Tx (&quot;</span> &lt;&lt; hex &lt;&lt; (int)ssrc 
                             &lt;&lt; <span class="stringliteral">&quot;): sending salute &quot;</span> &lt;&lt; <span class="stringliteral">&quot;no &quot;</span> &lt;&lt; dec &lt;&lt; i 
                             &lt;&lt; <span class="stringliteral">&quot;, at &quot;</span> &lt;&lt; tmstring 
                             &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;

                        <span class="comment">// Let&#39;s wait for the next cycle</span>
                        Thread::sleep(TimerPort::getTimer());
                        TimerPort::incTimer(1000);
                }
        }
};

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{

        <span class="comment">// Construct the two main threads. they will not run yet.</span>
        ccRTP_Hello_Rx *receiver = <span class="keyword">new</span> ccRTP_Hello_Rx;
        ccRTP_Hello_Tx *transmitter = <span class="keyword">new</span> ccRTP_Hello_Tx;
        
        cout &lt;&lt; <span class="stringliteral">&quot;This is rtphello, a very simple test program for ccRTP.&quot;</span> &lt;&lt; 
                endl &lt;&lt; <span class="stringliteral">&quot;Strike [Enter] when you are fed up with it.&quot;</span> &lt;&lt; endl;

        <span class="comment">// Start execution of hello now.</span>
        receiver-&gt;start();
        transmitter-&gt;start();

        cin.get();

        <span class="keyword">delete</span> transmitter;
        <span class="keyword">delete</span> receiver;

        cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;That&#39;s all.&quot;</span> &lt;&lt; endl;
        
        <span class="keywordflow">return</span> 0;
}

</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Sep 21 04:20:08 2010 for ccRTP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
