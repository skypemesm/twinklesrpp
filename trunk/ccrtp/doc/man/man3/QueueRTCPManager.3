.TH "QueueRTCPManager" 3 "21 Sep 2010" "ccRTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QueueRTCPManager \- 
.PP
Adds generic management of RTCP functions to an RTP data queue.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cqueue.h>\fP
.PP
Inherits \fBRTPDataQueue\fP, and \fBRTCPCompoundHandler\fP.
.PP
Inherited by \fBAVPQueue\fP.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRTCPSenderInfo\fP * \fBgetMRSenderInfo\fP (\fBSyncSource\fP &src)"
.br
.RI "\fIGet the most recent sender report received from a synchronization source. \fP"
.ti -1c
.RI "\fBRTCPReceiverInfo\fP * \fBgetMRReceiverInfo\fP (\fBSyncSource\fP &srcFrom)"
.br
.RI "\fIAsk for the info in the most recent receiver report about the local source received from the source given as parameter. \fP"
.ti -1c
.RI "void \fBsetLeavingDelay\fP (\fBmicrotimeout_t\fP delay)"
.br
.RI "\fISet how much time the stack will wait before deleting a synchronization source that has sent an RTCP BYE packet. \fP"
.ti -1c
.RI "void \fBsetEnd2EndDelay\fP (\fBmicrotimeout_t\fP t)"
.br
.RI "\fIThis method sets the maximum end to end delay allowed. \fP"
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetDefaultEnd2EndDelay\fP () const "
.br
.ti -1c
.RI "\fBmicrotimeout_t\fP \fBgetEnd2EndDelay\fP () const "
.br
.ti -1c
.RI "void \fBsetSendersControlFraction\fP (float fraction)"
.br
.RI "\fISpecify the fraction of the total control bandwith to be dedicated to senders reports. \fP"
.ti -1c
.RI "void \fBsetMinRTCPInterval\fP (\fBmicrotimeout_t\fP interval)"
.br
.RI "\fIManually set the minimum interval for sending RTP compound packets. \fP"
.ti -1c
.RI "uint32 \fBgetSendRTCPPacketCount\fP () const "
.br
.RI "\fIGet the total number of RTCP packets sent until now. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBQueueRTCPManager\fP (uint32 size=\fBRTPDataQueue::defaultMembersHashSize\fP, \fBRTPApplication\fP &app=defaultApplication())"
.br
.ti -1c
.RI "\fBQueueRTCPManager\fP (uint32 ssrc, uint32 size=\fBRTPDataQueue::defaultMembersHashSize\fP, \fBRTPApplication\fP &app=defaultApplication())"
.br
.ti -1c
.RI "virtual \fB~QueueRTCPManager\fP ()"
.br
.ti -1c
.RI "const \fBRTPApplication\fP & \fBgetApplication\fP ()"
.br
.ti -1c
.RI "void \fBsetControlBandwidth\fP (float fraction)"
.br
.ti -1c
.RI "float \fBgetControlBandwidth\fP () const "
.br
.ti -1c
.RI "void \fBcontrolTransmissionService\fP ()"
.br
.RI "\fIBuild and send RTCP packets following timing rules (including the 'timer reconsideration' algorithm). \fP"
.ti -1c
.RI "void \fBcontrolReceptionService\fP ()"
.br
.RI "\fIProcess incoming RTCP packets pending in the control reception socket. \fP"
.ti -1c
.RI "bool \fBcheckSSRCInRTCPPkt\fP (\fBSyncSourceLink\fP &sourceLink, bool is_new, InetAddress &na, tpport_t tp)"
.br
.RI "\fIAppy collision and loop detection and correction algorithm when receiving RTCP packets. \fP"
.ti -1c
.RI "void \fBendQueueRTCPManager\fP ()"
.br
.ti -1c
.RI "virtual void \fBonGotSR\fP (\fBSyncSource\fP &source, \fBSendReport\fP &SR, uint8 blocks)"
.br
.RI "\fIPlug-in for processing (acquire information carried in) an incoming RTCP Sender Report. \fP"
.ti -1c
.RI "virtual void \fBonGotRR\fP (\fBSyncSource\fP &source, \fBRecvReport\fP &RR, uint8 blocks)"
.br
.RI "\fIPlug-in for processing (acquire information carried in) an incoming RTCP Receiver Report. \fP"
.ti -1c
.RI "bool \fBonGotSDES\fP (\fBSyncSource\fP &source, \fBRTCPPacket\fP &pkt)"
.br
.ti -1c
.RI "virtual bool \fBonGotSDESChunk\fP (\fBSyncSource\fP &source, \fBSDESChunk\fP &chunk, size_t len)"
.br
.RI "\fIPlug-in for handling of SDES chunks. \fP"
.ti -1c
.RI "virtual void \fBonGotAPP\fP (\fBSyncSource\fP &, \fBRTCPCompoundHandler::APPPacket\fP &, size_t)"
.br
.RI "\fIPlug-in for handling of APP (application specific) RTCP packets. \fP"
.ti -1c
.RI "timeval \fBgetRTCPCheckInterval\fP ()"
.br
.ti -1c
.RI "uint32 \fBgetLastSendPacketCount\fP () const "
.br
.RI "\fIGet the number of data packets sent at the time the last SR was generated. \fP"
.ti -1c
.RI "void \fBsetPrevMembersNum\fP (uint32 n)"
.br
.ti -1c
.RI "uint32 \fBgetPrevMembersCount\fP () const "
.br
.ti -1c
.RI "size_t \fBdispatchBYE\fP (const std::string &reason)"
.br
.RI "\fIThis method is used to send an RTCP BYE packet. \fP"
.ti -1c
.RI "size_t \fBsendControlToDestinations\fP (unsigned char *buffer, size_t len)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Adds generic management of RTCP functions to an RTP data queue. 

Extends an RTP data i/o queue adding management of RTCP functions:
.PP
Provide feedback on the quality of the data distribution.
.PP
Convey the CNAME (persistent transport-level identifier) for every RTP source.
.PP
Control the sending rate of RTCP packets
.PP
Convey minimal control information about the participants
.PP
This class implements generic RTCP behaviour (as specified in RFC 1889/draft-ietf-avt-rtp-new) and may be specialized for specific profiles (see \fBAVPQueue\fP) or particular RTCP extensions.
.PP
\fBAuthor:\fP
.RS 4
Federico Montesino Pouzols <fedemp@altern.org> 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "QueueRTCPManager::QueueRTCPManager (uint32 size = \fC\fBRTPDataQueue::defaultMembersHashSize\fP\fP, \fBRTPApplication\fP & app = \fCdefaultApplication()\fP)\fC [protected]\fP"
.SS "QueueRTCPManager::QueueRTCPManager (uint32 ssrc, uint32 size = \fC\fBRTPDataQueue::defaultMembersHashSize\fP\fP, \fBRTPApplication\fP & app = \fCdefaultApplication()\fP)\fC [protected]\fP"
.SS "virtual QueueRTCPManager::~QueueRTCPManager ()\fC [protected, virtual]\fP"
.SH "Member Function Documentation"
.PP 
.SS "bool QueueRTCPManager::checkSSRCInRTCPPkt (\fBSyncSourceLink\fP & sourceLink, bool is_new, InetAddress & na, tpport_t tp)\fC [protected]\fP"
.PP
Appy collision and loop detection and correction algorithm when receiving RTCP packets. Follows section 8.2 in draft-ietf-avp-rtp-new.
.PP
\fBParameters:\fP
.RS 4
\fIsourceLink\fP link to the source object. 
.br
\fIis_new\fP whether the source has been just recorded. 
.br
\fIna\fP RTCP packet network address. 
.br
\fItp\fP RTCP packet source transport port.
.RE
.PP
\fBReturns:\fP
.RS 4
whether the packet must not be discarded. 
.RE
.PP

.SS "void QueueRTCPManager::controlReceptionService ()\fC [protected]\fP"
.PP
Process incoming RTCP packets pending in the control reception socket. 
.SS "void QueueRTCPManager::controlTransmissionService ()\fC [protected]\fP"
.PP
Build and send RTCP packets following timing rules (including the 'timer reconsideration' algorithm). 
.SS "size_t QueueRTCPManager::dispatchBYE (const std::string & reason)\fC [protected, virtual]\fP"
.PP
This method is used to send an RTCP BYE packet. An RTCP BYE packet is sent when one of the the following circumstances occur:
.IP "\(bu" 2
when leaving the session
.IP "\(bu" 2
when we have detected that another synchronization source in the same session is using the same SSRC identifier as us.
.PP
.PP
Try to post a BYE message. It will send a BYE packet as long as at least one RTP or RTCP packet has been sent before. If the number of members in the session is more than 50, the algorithm described in section 6.3.7 of RFC 3550 is applied in order to avoid a flood of BYE messages.
.PP
\fBParameters:\fP
.RS 4
\fIreason\fP reason to specify in the BYE packet. 
.RE
.PP

.PP
Reimplemented from \fBRTPQueueBase\fP.
.SS "void QueueRTCPManager::endQueueRTCPManager ()\fC [protected]\fP"
.SS "const \fBRTPApplication\fP& QueueRTCPManager::getApplication ()\fC [inline, protected]\fP"
.SS "float QueueRTCPManager::getControlBandwidth () const\fC [inline, protected]\fP"
.PP
Reimplemented in \fBAVPQueue\fP.
.SS "\fBmicrotimeout_t\fP QueueRTCPManager::getDefaultEnd2EndDelay () const\fC [inline]\fP"
.SS "\fBmicrotimeout_t\fP QueueRTCPManager::getEnd2EndDelay () const\fC [inline]\fP"
.SS "uint32 QueueRTCPManager::getLastSendPacketCount () const\fC [inline, protected]\fP"
.PP
Get the number of data packets sent at the time the last SR was generated. 
.SS "\fBRTCPReceiverInfo\fP* QueueRTCPManager::getMRReceiverInfo (\fBSyncSource\fP & srcFrom)"
.PP
Ask for the info in the most recent receiver report about the local source received from the source given as parameter. \fBParameters:\fP
.RS 4
\fIsrcFrom\fP Source of the receiver info. 
.RE
.PP
\fBReturns:\fP
.RS 4
most recent receiver info received from src. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP when no receiver report has been received from the specified source. 
.RE
.PP

.SS "\fBRTCPSenderInfo\fP* QueueRTCPManager::getMRSenderInfo (\fBSyncSource\fP & src)"
.PP
Get the most recent sender report received from a synchronization source. \fBParameters:\fP
.RS 4
\fIsrc\fP Synchronization source of the sender info. 
.RE
.PP
\fBReturns:\fP
.RS 4
Most recent sender info received from src. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP when no sender report has been received from the specified source. 
.RE
.PP

.SS "uint32 QueueRTCPManager::getPrevMembersCount () const\fC [inline, protected]\fP"
.SS "timeval QueueRTCPManager::getRTCPCheckInterval ()\fC [inline, protected]\fP"
.SS "uint32 QueueRTCPManager::getSendRTCPPacketCount () const\fC [inline]\fP"
.PP
Get the total number of RTCP packets sent until now. 
.SS "virtual void QueueRTCPManager::onGotAPP (\fBSyncSource\fP &, \fBRTCPCompoundHandler::APPPacket\fP &, size_t)\fC [inline, protected, virtual]\fP"
.PP
Plug-in for handling of APP (application specific) RTCP packets. \fBParameters:\fP
.RS 4
\fI-\fP Synchronization source of this packet. 
.br
\fI-\fP RTCP APP packet struct. 
.br
\fI-\fP Length of the app data packet, including ssrc. name and app. specific data. 
.RE
.PP

.SS "virtual void QueueRTCPManager::onGotRR (\fBSyncSource\fP & source, \fBRecvReport\fP & RR, uint8 blocks)\fC [protected, virtual]\fP"
.PP
Plug-in for processing (acquire information carried in) an incoming RTCP Receiver Report. The default implementation in this class only processes the receiver report blocks about the local source.
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP Synchronization source this report comes from. 
.br
\fIRR\fP Receiver report structure 
.br
\fIblocks\fP Number of report blocks in the packet 
.RE
.PP

.SS "bool QueueRTCPManager::onGotSDES (\fBSyncSource\fP & source, \fBRTCPPacket\fP & pkt)\fC [protected]\fP"\fBParameters:\fP
.RS 4
\fIsource\fP Synchronization source of SDES RTCP packet. 
.br
\fIpkt\fP SDES RTCP packet received. 
.RE
.PP

.SS "virtual bool QueueRTCPManager::onGotSDESChunk (\fBSyncSource\fP & source, \fBSDESChunk\fP & chunk, size_t len)\fC [protected, virtual]\fP"
.PP
Plug-in for handling of SDES chunks. \fBParameters:\fP
.RS 4
\fIsource\fP Synchronization source of SDES chunk. 
.br
\fIchunk\fP SDES chunk structure. 
.br
\fIlen\fP Length of chunk, in octets.
.RE
.PP
\fBReturns:\fP
.RS 4
whether there was a CNAME. 
.RE
.PP

.SS "virtual void QueueRTCPManager::onGotSR (\fBSyncSource\fP & source, \fBSendReport\fP & SR, uint8 blocks)\fC [protected, virtual]\fP"
.PP
Plug-in for processing (acquire information carried in) an incoming RTCP Sender Report. The default implementation in this class only processes the sender information and the receiver report blocks about the local source.
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP Synchronization source this report comes from. 
.br
\fISR\fP Sender report structure. 
.br
\fIblocks\fP Number of report blocks in the packet. 
.RE
.PP

.SS "size_t QueueRTCPManager::sendControlToDestinations (unsigned char * buffer, size_t len)\fC [protected]\fP"
.SS "void QueueRTCPManager::setControlBandwidth (float fraction)\fC [inline, protected]\fP"
.PP
Reimplemented in \fBAVPQueue\fP.
.SS "void QueueRTCPManager::setEnd2EndDelay (\fBmicrotimeout_t\fP t)\fC [inline]\fP"
.PP
This method sets the maximum end to end delay allowed. If the processing delay plus the trip time for a packet is greater than the end to end delay, the packet is discarded, and the application cannot get it.
.PP
This is a way of setting an upper bound to the end to end delay, computed as the elapsed time between the packet timestamping at the sender side, and the picking of the packet at the receiver side.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP maximum end to end delay allowed. A value of 0 implies there is no limit and is the default 
.RE
.PP

.SS "void QueueRTCPManager::setLeavingDelay (\fBmicrotimeout_t\fP delay)\fC [inline]\fP"
.PP
Set how much time the stack will wait before deleting a synchronization source that has sent an RTCP BYE packet. \fBParameters:\fP
.RS 4
\fIdelay\fP delay in microseconds.
.RE
.PP
\fBNote:\fP
.RS 4
The default delay is 1000000 microseconds 
.RE
.PP

.SS "void QueueRTCPManager::setMinRTCPInterval (\fBmicrotimeout_t\fP interval)\fC [inline]\fP"
.PP
Manually set the minimum interval for sending RTP compound packets. \fBParameters:\fP
.RS 4
\fIinterval\fP minimum interval between RTCP packets, in microseconds.
.RE
.PP
\fBSee also:\fP
.RS 4
computeRTCPInterval() 
.RE
.PP

.SS "void QueueRTCPManager::setPrevMembersNum (uint32 n)\fC [inline, protected]\fP"\fBParameters:\fP
.RS 4
\fIn\fP Number of members. 
.RE
.PP

.SS "void QueueRTCPManager::setSendersControlFraction (float fraction)\fC [inline]\fP"
.PP
Specify the fraction of the total control bandwith to be dedicated to senders reports. \fBParameters:\fP
.RS 4
\fIfraction\fP fraction of bandwidth, must be between 0 an 1.
.RE
.PP
This method sets the fraction of the global control bandwidth that will be dedicated to senders reports. Of course, \fC1 - fraction\fP will be dedicated to receivers reports.
.PP
\fBSee also:\fP
.RS 4
\fBsetControlBandwidth\fP 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "uint32 \fBQueueRTCPManager::rtcpPMembers\fP"
.SS "timeval \fBQueueRTCPManager::rtcpTc\fP"
.SS "timeval \fBQueueRTCPManager::rtcpTn\fP"
.SS "timeval \fBQueueRTCPManager::rtcpTp\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for ccRTP from the source code.
