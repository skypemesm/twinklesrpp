.TH "SyncSource" 3 "21 Sep 2010" "ccRTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SyncSource \- 
.PP
Synchronization source in an RTP session.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <sources.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBState\fP { \fBstateUnknown\fP, \fBstatePrevalid\fP, \fBstateActive\fP, \fBstateInactive\fP, \fBstateLeaving\fP }"
.br
.RI "\fISynchronization source states during an RTP session. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSyncSource\fP (uint32 ssrc)"
.br
.ti -1c
.RI "\fB~SyncSource\fP ()"
.br
.ti -1c
.RI "\fBState\fP \fBgetState\fP () const "
.br
.ti -1c
.RI "bool \fBisSender\fP () const "
.br
.RI "\fIWhether this source sends RTP data packets. \fP"
.ti -1c
.RI "uint32 \fBgetID\fP () const "
.br
.ti -1c
.RI "\fBParticipant\fP * \fBgetParticipant\fP () const "
.br
.RI "\fIGet the participant this synchronization source is asociated to. \fP"
.ti -1c
.RI "tpport_t \fBgetDataTransportPort\fP () const "
.br
.ti -1c
.RI "tpport_t \fBgetControlTransportPort\fP () const "
.br
.ti -1c
.RI "const InetAddress & \fBgetNetworkAddress\fP () const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBSyncSource\fP (const \fBSyncSource\fP &source)"
.br
.ti -1c
.RI "\fBSyncSource\fP & \fBoperator=\fP (const \fBSyncSource\fP &source)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBSyncSourceHandler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Synchronization source in an RTP session. 

Each synchronization source in an RTP session is identified by a 32-bit numeric SSRC identifier. Each \fBSyncSource\fP object is related to a \fBParticipant\fP object, which can be retrieved through the \fBgetParticipant()\fP method.
.PP
\fBAuthor:\fP
.RS 4
Federico Montesino Pouzols <fedemp@altern.org> 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
.PP
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSyncSource::State\fP"
.PP
Synchronization source states during an RTP session. In general, new synchronization sources are not considered valid until multiple valid data packets or a valid RTCP compound packet has been received from the new source (
.PP
\fBSee also:\fP
.RS 4
\fBIncomingDataQueue::setMinValidPacketSequence()\fP). Thus, the source will probably be in \fBstatePrevalid\fP before reaching one of the two states that indicate a valid source: \fBstateActive\fP and \fBstateInactive\fP.
.RE
.PP
A valid participant is in stateActive state if RTP and/or RTCP packets are currently being received from it. If, after a small number of RTCP report intervals (see \fBIncomingDataQueue::setSourceExpirationPeriod()\fP ), no packets are received, it will reach the stateInactive state. If, after a small number of RTCP report intervals, no packet is received from an inactive source, it will be deleted.
.PP
If RTCP is being used, after receiving a BYE RTCP packet from a synchronization source, it will reach the stateLeaving state and will be deleted after a delay (see \fBQueueRTCPManager::setLeavingDelay()\fP).
.PP
Sources in statePrevalid and stateLeaving are not counted for the number of session members estimation. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIstateUnknown \fP\fP
No valid packet has been received. 
.TP
\fB\fIstatePrevalid \fP\fP
Some packets have been received, but source validity not yet guaranteed. 
.TP
\fB\fIstateActive \fP\fP
We currently receive packets (data or control) from this source. 
.TP
\fB\fIstateInactive \fP\fP
Was active in the near past but no packet from this source has been received lately. 
.TP
\fB\fIstateLeaving \fP\fP
An RTCP BYE has been received from the source. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SyncSource::SyncSource (uint32 ssrc)"\fBParameters:\fP
.RS 4
\fIssrc\fP SSRC identifier of the source, unique in each session. 
.RE
.PP

.SS "SyncSource::~SyncSource ()"
.SS "SyncSource::SyncSource (const \fBSyncSource\fP & source)\fC [protected]\fP"\fBParameters:\fP
.RS 4
\fIsource\fP The RTPSource object being copied 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "tpport_t SyncSource::getControlTransportPort () const\fC [inline]\fP"
.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SS "tpport_t SyncSource::getDataTransportPort () const\fC [inline]\fP"
.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SS "uint32 SyncSource::getID () const\fC [inline]\fP"
.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SS "const InetAddress& SyncSource::getNetworkAddress () const\fC [inline]\fP"
.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SS "\fBParticipant\fP* SyncSource::getParticipant () const\fC [inline]\fP"
.PP
Get the participant this synchronization source is asociated to. \fBReturn values:\fP
.RS 4
\fINULL\fP if the stack has not been yet able to identify the participant this source is associated to. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP, and \fBrtplisten.cpp\fP.
.SS "\fBState\fP SyncSource::getState () const\fC [inline]\fP"
.SS "bool SyncSource::isSender () const\fC [inline]\fP"
.PP
Whether this source sends RTP data packets. 
.PP
\fBExamples: \fP
.in +1c
\fBccrtptest.cpp\fP.
.SS "\fBSyncSource\fP& SyncSource::operator= (const \fBSyncSource\fP & source)\fC [protected]\fP"
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBSyncSourceHandler\fP\fC [friend]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for ccRTP from the source code.
