.TH "RTPPacket" 3 "21 Sep 2010" "ccRTP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RTPPacket \- 
.PP
A base class for both \fBIncomingRTPPkt\fP and \fBOutgoingRTPPkt\fP.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <rtppkt.h>\fP
.PP
Inherited by \fBIncomingRTPPkt\fP, and \fBOutgoingRTPPkt\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBRFC2833Payload\fP"
.br
.RI "\fIa structure defining RFC2833 Telephony events. \fP"
.ti -1c
.RI "struct \fBRTPFixedHeader\fP"
.br
.RI "\fIRTP fixed header as it is send through the network. \fP"
.ti -1c
.RI "struct \fBRTPHeaderExt\fP"
.br
.RI "\fIFixed component of the variable-length header extension, appended to the fixed header, after the CSRC list, when X == 1. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRTPPacket\fP (const unsigned char *const block, size_t len, bool duplicate=false)"
.br
.RI "\fIConstructor, construct a packet object given the memory zone its content (header and payload) is stored. \fP"
.ti -1c
.RI "\fBRTPPacket\fP (size_t hdrlen, size_t plen, uint8 paddinglen, \fBCryptoContext\fP *pcc=NULL)"
.br
.RI "\fIConstruct a packet object without specifying its real content yet. \fP"
.ti -1c
.RI "uint32 \fBgetHeaderSize\fP () const "
.br
.RI "\fIGet the length of the header, including contributing sources identifiers and header extension, if present. \fP"
.ti -1c
.RI "const uint8 *const \fBgetPayload\fP () const "
.br
.ti -1c
.RI "uint32 \fBgetPayloadSize\fP () const "
.br
.ti -1c
.RI "\fBPayloadType\fP \fBgetPayloadType\fP () const "
.br
.ti -1c
.RI "uint16 \fBgetSeqNum\fP () const "
.br
.ti -1c
.RI "uint32 \fBgetTimestamp\fP () const "
.br
.ti -1c
.RI "uint8 \fBgetProtocolVersion\fP () const "
.br
.ti -1c
.RI "bool \fBisPadded\fP () const "
.br
.RI "\fIAsk whether the packet contains padding bytes at the end. \fP"
.ti -1c
.RI "uint8 \fBgetPaddingSize\fP () const "
.br
.RI "\fIGet the number of octets padding the end of the payload section. \fP"
.ti -1c
.RI "bool \fBisMarked\fP () const "
.br
.RI "\fIAsk whether the packet is marked (for isntance, is a new talk spurt in some audio profiles). \fP"
.ti -1c
.RI "bool \fBisExtended\fP () const "
.br
.RI "\fIAsk whether the packet contains header extensions. \fP"
.ti -1c
.RI "uint16 \fBgetCSRCsCount\fP () const "
.br
.RI "\fIGet the number of contributing sources specified in the packet header. \fP"
.ti -1c
.RI "const uint32 * \fBgetCSRCs\fP () const "
.br
.RI "\fIGet the 32-bit identifiers of the contributing sources for the packet as an array, of length \fBgetCSRCsCount()\fP. \fP"
.ti -1c
.RI "uint16 \fBgetHdrExtUndefined\fP () const "
.br
.RI "\fIGet the first 16 bits (in network order) of the header of the RTP header extension. \fP"
.ti -1c
.RI "uint32 \fBgetHdrExtSize\fP () const "
.br
.RI "\fIGet the length (in octets) of the data contained in the header extension. \fP"
.ti -1c
.RI "const unsigned char * \fBgetHdrExtContent\fP () const "
.br
.RI "\fIGet the content of the header extension. \fP"
.ti -1c
.RI "const unsigned char *const \fBgetRawPacket\fP () const "
.br
.RI "\fIGet the raw packet as it will be sent through the network. \fP"
.ti -1c
.RI "uint32 \fBgetRawPacketSize\fP () const "
.br
.RI "\fIGet the raw packet length, including header, extension, payload and padding. \fP"
.ti -1c
.RI "uint32 \fBgetRawPacketSizeSrtp\fP () const "
.br
.ti -1c
.RI "size_t \fBgetSizeOfFixedHeader\fP () const "
.br
.ti -1c
.RI "struct \fBRFC2833Payload\fP * \fBgetRaw2833Payload\fP (void)"
.br
.RI "\fIFetch a raw 2833 packet. \fP"
.ti -1c
.RI "uint16 \fBget2833Duration\fP (void)"
.br
.RI "\fIFetch 2833 duration field. \fP"
.ti -1c
.RI "void \fBset2833Duration\fP (uint16 timestamp)"
.br
.RI "\fISet 2833 duration field. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~RTPPacket\fP ()"
.br
.RI "\fIDestructor, free the buffer provided in the constructor. \fP"
.ti -1c
.RI "void \fBendPacket\fP ()"
.br
.RI "\fIFree memory allocated for the packet. \fP"
.ti -1c
.RI "RTPFixedHeader * \fBgetHeader\fP () const "
.br
.RI "\fIReturn low level structure for the header of the packet. \fP"
.ti -1c
.RI "void \fBsetExtension\fP (bool e)"
.br
.ti -1c
.RI "const RTPHeaderExt * \fBgetHeaderExt\fP () const "
.br
.RI "\fIGet a pointer to RTPHeaderExt pointing after the RTP header (fixed part plus contributing sources). \fP"
.ti -1c
.RI "uint32 \fBgetRawTimestamp\fP () const "
.br
.RI "\fIObtain the absolute timestamp carried in the packet header. \fP"
.ti -1c
.RI "void \fBsetbuffer\fP (const void *src, size_t len, size_t pos)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint16 \fBcachedSeqNum\fP"
.br
.RI "\fIPacket sequence number in host order. \fP"
.ti -1c
.RI "uint32 \fBcachedTimestamp\fP"
.br
.RI "\fIPacket timestamp in host order (includes initial shift). \fP"
.ti -1c
.RI "uint32 \fBsrtpDataOffset\fP"
.br
.RI "\fIOffset into packet memory pointing to area for SRTP data. \fP"
.ti -1c
.RI "int32 \fBsrtpLength\fP"
.br
.RI "\fILebgth of additional SRTP data. \fP"
.ti -1c
.RI "uint32 \fBtotal\fP"
.br
.RI "\fItotal length, including header, payload and padding \fP"
.ti -1c
.RI "uint32 \fBpayloadSize\fP"
.br
.RI "\fInote: payload (not full packet) size. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A base class for both \fBIncomingRTPPkt\fP and \fBOutgoingRTPPkt\fP. 

Provides common low level header structures and related methods. This class provides an interface that allows for partial and generic manipulation of RTP data packets. Values are returned in host order, except raw structures, which are returned as they are sent through the network.
.PP
\fBAuthor:\fP
.RS 4
David Sugar <dyfet@ostel.com> 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "RTPPacket::RTPPacket (const unsigned char *const  block, size_t len, bool duplicate = \fCfalse\fP)"
.PP
Constructor, construct a packet object given the memory zone its content (header and payload) is stored. Commonly used to build \fBRTPPacket\fP objects from incoming data.
.PP
\fBParameters:\fP
.RS 4
\fIblock\fP whole packet 
.br
\fIlen\fP total length (header + payload + padding) of the packet 
.br
\fIduplicate\fP whether to memcopy the packet. At present, this feature is not used. 
.RE
.PP
\fBNote:\fP
.RS 4
used in \fBIncomingRTPPkt\fP. 
.RE
.PP

.SS "RTPPacket::RTPPacket (size_t hdrlen, size_t plen, uint8 paddinglen, \fBCryptoContext\fP * pcc = \fCNULL\fP)"
.PP
Construct a packet object without specifying its real content yet. Commonly used for outgoing packets. Header fields and payload must be filled in by another methods or by a derived constructor.
.PP
\fBParameters:\fP
.RS 4
\fIhdrlen\fP length of the header (including CSRC and extension). 
.br
\fIplen\fP payload length. 
.br
\fIpaddinglen\fP pad packet to a multiple of paddinglen 
.RE
.PP
\fBNote:\fP
.RS 4
used in \fBOutgoingRTPPkt\fP. 
.RE
.PP

.SS "virtual RTPPacket::~RTPPacket ()\fC [inline, protected, virtual]\fP"
.PP
Destructor, free the buffer provided in the constructor. 
.SH "Member Function Documentation"
.PP 
.SS "void RTPPacket::endPacket ()\fC [protected]\fP"
.PP
Free memory allocated for the packet. 
.SS "uint16 RTPPacket::get2833Duration (void)\fC [inline]\fP"
.PP
Fetch 2833 duration field. \fBReturns:\fP
.RS 4
2833 duration in native host machine byte order. 
.RE
.PP

.SS "const uint32* RTPPacket::getCSRCs () const\fC [inline]\fP"
.PP
Get the 32-bit identifiers of the contributing sources for the packet as an array, of length \fBgetCSRCsCount()\fP. \fBReturns:\fP
.RS 4
An array of CSRC identifiers as they are in the packet (in network order). 
.RE
.PP

.SS "uint16 RTPPacket::getCSRCsCount () const\fC [inline]\fP"
.PP
Get the number of contributing sources specified in the packet header. 
.SS "const unsigned char* RTPPacket::getHdrExtContent () const\fC [inline]\fP"
.PP
Get the content of the header extension. \fBReturns:\fP
.RS 4
NULL if the packet has no header extension, otherwise a pointer to the packet header extension content. 
.RE
.PP

.SS "uint32 RTPPacket::getHdrExtSize () const\fC [inline]\fP"
.PP
Get the length (in octets) of the data contained in the header extension. Note that this length does not include the four octets at the beginning of the header extension.
.PP
\fBReturns:\fP
.RS 4
0 if the packet has no header extension, otherwise the length.
.RE
.PP
\fBNote:\fP
.RS 4
0 is a valid value for this field, so \fBRTPPacket::isExtended()\fP should be used. 
.RE
.PP

.SS "uint16 RTPPacket::getHdrExtUndefined () const\fC [inline]\fP"
.PP
Get the first 16 bits (in network order) of the header of the RTP header extension. Its meaning is undefined at this level.
.PP
\fBReturns:\fP
.RS 4
0 if the packet has no header extension, otherwise the first 16 bits of the header extension, in network order.
.RE
.PP
\fBNote:\fP
.RS 4
0 could be a valid value for the first 16 bits, in that case \fBRTPPacket::isExtended()\fP should be use. 
.RE
.PP

.SS "RTPFixedHeader* RTPPacket::getHeader () const\fC [inline, protected]\fP"
.PP
Return low level structure for the header of the packet. \fBReturns:\fP
.RS 4
RTPFixedHeader pointer to the header of the packet. 
.RE
.PP

.SS "const RTPHeaderExt* RTPPacket::getHeaderExt () const\fC [inline, protected]\fP"
.PP
Get a pointer to RTPHeaderExt pointing after the RTP header (fixed part plus contributing sources). No check for for the X bit is done.
.PP
\fBReturns:\fP
.RS 4
header extension if present, garbage if not. 
.RE
.PP

.SS "uint32 RTPPacket::getHeaderSize () const\fC [inline]\fP"
.PP
Get the length of the header, including contributing sources identifiers and header extension, if present. \fBReturns:\fP
.RS 4
number of octets. 
.RE
.PP

.SS "uint8 RTPPacket::getPaddingSize () const\fC [inline]\fP"
.PP
Get the number of octets padding the end of the payload section. \fBReturns:\fP
.RS 4
Padding length in octets. 
.RE
.PP

.SS "const uint8* const RTPPacket::getPayload () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
pointer to the payload section of the packet. 
.RE
.PP

.SS "uint32 RTPPacket::getPayloadSize () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
length of the payload section, in octets. 
.RE
.PP

.SS "\fBPayloadType\fP RTPPacket::getPayloadType () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
value of the PT header field. 
.RE
.PP

.SS "uint8 RTPPacket::getProtocolVersion () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
RTP protocol version of packet. 
.RE
.PP

.SS "struct \fBRFC2833Payload\fP* RTPPacket::getRaw2833Payload (void)\fC [inline, read]\fP"
.PP
Fetch a raw 2833 packet. \fBReturns:\fP
.RS 4
low level 2833 data structure. 
.RE
.PP

.SS "const unsigned char* const RTPPacket::getRawPacket () const\fC [inline]\fP"
.PP
Get the raw packet as it will be sent through the network. \fBReturns:\fP
.RS 4
memory zone where the raw packet structure is stored in. 
.RE
.PP

.SS "uint32 RTPPacket::getRawPacketSize () const\fC [inline]\fP"
.PP
Get the raw packet length, including header, extension, payload and padding. \fBReturns:\fP
.RS 4
size of the raw packet structure. 
.RE
.PP

.SS "uint32 RTPPacket::getRawPacketSizeSrtp () const\fC [inline]\fP"
.SS "uint32 RTPPacket::getRawTimestamp () const\fC [inline, protected]\fP"
.PP
Obtain the absolute timestamp carried in the packet header. \fBReturns:\fP
.RS 4
32-bit timestamp in host order. 
.RE
.PP

.SS "uint16 RTPPacket::getSeqNum () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
value of the sequence number header field, in host order. 
.RE
.PP

.SS "size_t RTPPacket::getSizeOfFixedHeader () const\fC [inline]\fP"
.SS "uint32 RTPPacket::getTimestamp () const\fC [inline]\fP"\fBReturns:\fP
.RS 4
packet timestamp in host order. 
.RE
.PP

.SS "bool RTPPacket::isExtended () const\fC [inline]\fP"
.PP
Ask whether the packet contains header extensions. \fBReturns:\fP
.RS 4
true if the header extension bit is 1. 
.RE
.PP

.SS "bool RTPPacket::isMarked () const\fC [inline]\fP"
.PP
Ask whether the packet is marked (for isntance, is a new talk spurt in some audio profiles). \fBReturns:\fP
.RS 4
true is the header marker bit is 1. 
.RE
.PP

.SS "bool RTPPacket::isPadded () const\fC [inline]\fP"
.PP
Ask whether the packet contains padding bytes at the end. \fBReturns:\fP
.RS 4
true if the header padding bit is 1. 
.RE
.PP

.SS "void RTPPacket::set2833Duration (uint16 timestamp)\fC [inline]\fP"
.PP
Set 2833 duration field. \fBParameters:\fP
.RS 4
\fItimestamp\fP to use, native host machine byte order. 
.RE
.PP

.SS "void RTPPacket::setbuffer (const void * src, size_t len, size_t pos)\fC [inline, protected]\fP"
.SS "void RTPPacket::setExtension (bool e)\fC [inline, protected]\fP"
.SH "Member Data Documentation"
.PP 
.SS "uint16 \fBRTPPacket::cachedSeqNum\fP\fC [protected]\fP"
.PP
Packet sequence number in host order. 
.SS "uint32 \fBRTPPacket::cachedTimestamp\fP\fC [protected]\fP"
.PP
Packet timestamp in host order (includes initial shift). 
.SS "uint32 \fBRTPPacket::payloadSize\fP\fC [protected]\fP"
.PP
note: payload (not full packet) size. 
.SS "uint32 \fBRTPPacket::srtpDataOffset\fP\fC [protected]\fP"
.PP
Offset into packet memory pointing to area for SRTP data. This offset points to the memory where the SRTP protect will store the authentication and MKI data. 
.SS "int32 \fBRTPPacket::srtpLength\fP\fC [protected]\fP"
.PP
Lebgth of additional SRTP data. Covers the SRTP authentication and MKI data. 
.SS "uint32 \fBRTPPacket::total\fP\fC [protected]\fP"
.PP
total length, including header, payload and padding 

.SH "Author"
.PP 
Generated automatically by Doxygen for ccRTP from the source code.
